# A0124791A
###### C:\Users\Barnabas\Documents\GitHub\main\src\controller\CommandBoxController.java
``` java
package controller;

import java.io.IOException;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.VBox;
import utilities.ErrorProcessor;

/**
 * CommandBoxController controls the text field where the user keys in commands
 * <p>
 * It displays feedback to user and passes the input in the text field to MainApp
 * 
 * @author Hongchao
 *
 */
public class CommandBoxController extends VBox{
	
	// ================================================================
	// FXML
	// ================================================================
	private static final String FXML_PATH = "/view/CommandBoxView.fxml";
		
	@FXML 
	private Label feedback;
	@FXML 
	private Label prediction;
	@FXML 
	private TextField commandBox;
	
	// ================================================================
	// Fields
	// ================================================================
    private MainApp mainApp;	// Reference to the main application
	
	public CommandBoxController(){
		FXMLLoader loader = new FXMLLoader();
        loader.setLocation(getClass().getResource(FXML_PATH));
        loader.setRoot(this);
        loader.setController(this);
        try {
        	loader.load();
		} catch (IOException e) {
			ErrorProcessor.alert(e.toString());
		}
	}
	
	@FXML
	public void initialize(){
		clearFeedback();
		clearPredictionFeedback();
	}
	
	/**
	 * handleUserInput is called when the user presses enter     
	 * The user input will be passed to MainApp for processing
	 * The command box will be cleared after each call
	 */
	@FXML
	public void handleUserInput(){
		String userInput = commandBox.getText();
		mainApp.handleUserCommand(userInput);
		commandBox.clear();
	}
	
	/**
	 * parseUserInput is called when the user keys in something   
	 * The user input will be passed to MainApp for processing
	 * 
	 */
	@FXML
	public void parseUserInput(){
		String userInput = commandBox.getText();
		mainApp.parseUserCommand(userInput);
	}
	
	public void clearFeedback() {
		feedback.setText("");
	}
	
	public void clearPredictionFeedback() {
		prediction.setText("");
	}
	
	// ================================================================
    // Setter methods
    // ================================================================
    
	/**
     * Is called by the main application to give a reference back to itself
     * 
     * @param mainApp
     */
    public void setMainApp(MainApp mainApp) {
        this.mainApp = mainApp;
    }
    	
    public void setFeedback(String txt){
    	feedback.setText(txt);
    	feedback.setId("successMsg");
    }
    
    public void setErrorFeedback(String txt){
    	feedback.setText(txt);
    	feedback.setId("errorMsg");
    }
    
    public void setPredictionFeedback(String txt){
    	prediction.setText(txt);
    	prediction.setId("predictionMsg");
    }
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\controller\HelpBoxController.java
``` java
package controller;

import java.io.IOException;
import javafx.fxml.FXMLLoader;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import utilities.ErrorProcessor;

/**
 * HelpBoxController controls the help menu
 * <p> 
 * It displays to the user all possible commands that can be used 
 *
 * @author Hongchao
 * 
 */
public class HelpBoxController extends VBox{
	
	// ================================================================
    // FXML
    // ================================================================
	private static final String FXML_PATH = "/view/HelpBoxView.fxml";
	
	// ================================================================
    // Help messages
    // ================================================================
	private static final String ADD_TIP = "Add/Insert <Item Name> -d <Starting Date> <Ending Date> -i <Details>";
	private static final String ADD_DETAILS = "This command adds a new item to the list.\n";
	private static final String ACK_TIP = "Ack/Acknowledge <Item Name> : Marks an item as completed";
	private static final String ACK_DETAILS = "This command marks an item as completed and hides it\n";
	private static final String COMPLETED_TIP = "Completed : Displays the list of completed items";
	private static final String COMPLETED_DETAILS = "\n";
	private static final String DELETE_TIP = "Remove/Delete <Item Index>";
	private static final String DELETE_DETAILS = "This command removes an item from the list permenantly\n";
	private static final String EDIT_TIP = "Edit/Change <Item Index> <Task Name> -d <Starting Date> <Ending Date> -i <Details>";
	private static final String EDIT_DETAILS = "This command edits an item identified by it's index, and changes the content accordingly\n";
	private static final String FILEPATH_TIP = "Filepath <Directory Path> : Changes file location. Note: Exclude file extension";
	private static final String FILEPATH_DETAILS = "\n";
	private static final String HOME_TIP = "Home : Displays the original list";
	private static final String HOME_DETAILS = "\n";
	private static final String SEARCH_TIP = "Find/Search <Keywords> : Displays the list of items containing the keywords";
	private static final String SEARCH_DETAILS = "\n";
	private static final String NAME_TIP = "Name <User Name> : Changes the user name";
	private static final String NAME_DETAILS = "\n";
	private static final String UNDO_TIP = "Undo: Reverts your last changes.";
	private static final String UNDO_DETAILS = "";

	public HelpBoxController(){
        try {
    		FXMLLoader loader = new FXMLLoader();
            loader.setLocation(getClass().getResource(FXML_PATH));
            loader.setRoot(this);
            loader.setController(this);
        	loader.load();
		} catch (IOException e) {
			ErrorProcessor.alert(e.toString());
		}
        initHelpEntry();
        this.setId("helpBox");
	}
	
	private void initHelpEntry(){
		createEntry(ADD_TIP);
		createEntry(ADD_DETAILS);
		createEntry(ACK_TIP);
		createEntry(ACK_DETAILS);
		createEntry(COMPLETED_TIP);
		createEntry(COMPLETED_DETAILS);
		createEntry(DELETE_TIP);
		createEntry(DELETE_DETAILS);
		createEntry(EDIT_TIP);
		createEntry(EDIT_DETAILS);
		createEntry(FILEPATH_TIP);
		createEntry(FILEPATH_DETAILS);
		createEntry(HOME_TIP);
		createEntry(HOME_DETAILS);
		createEntry(SEARCH_TIP);
		createEntry(SEARCH_DETAILS);
		createEntry(NAME_TIP);
		createEntry(NAME_DETAILS);
		createEntry(UNDO_TIP);	
		createEntry(UNDO_DETAILS);	
	}
	
	private void createEntry(String text){
		Text entry = new Text(text);
		entry.setId("helpEntry");
		entry.setWrappingWidth(700);
		this.getChildren().add(entry);
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\controller\InfoPanelController.java
``` java
package controller;

import java.io.IOException;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import utilities.DayProcessor;
import utilities.ErrorProcessor;

/**
 * InfoPanelController controls the information panel 
 * <p>
 * It displays the user's name and today's date
 * It provides a preview of the task being added, deleted or edited 
 *
 * @author Hongchao
 * 
 */
public class InfoPanelController extends VBox{
	
    // ================================================================
    // FXML
    // ================================================================
	private static final String FXML_PATH = "/view/InfoPanelView.fxml";
		
	@FXML 
	private Label userName;
	@FXML 
	private Label todayDay;
	@FXML 
	private Label todayDate;
	@FXML 
	private Label numTasksDue;
	@FXML 
	private VBox taskPreview;
	
    // ================================================================
    // Format of panel messages
    // ================================================================
	private static final String WELCOME_MESSAGE = "Hi %s";
	private static final String TASK_DUE_MESSAGE = "%d Task(s) due";
	
    // ================================================================
    // Format of task preview
    // ================================================================
	private static final String TASK_NAME_DISPLAY = "NAME: %s";
	private static final String TASK_DETAIL_DISPLAY = "INFO: %s";
	private static final String TASK_START_DISPLAY = "START: %s";
	private static final String TASK_END_DISPLAY = "END: %s";
		
	public InfoPanelController(String user, int numTasks){
		FXMLLoader loader = new FXMLLoader();
        loader.setLocation(getClass().getResource(FXML_PATH));
        loader.setRoot(this);
        loader.setController(this);
        try {
        	loader.load();
		} catch (IOException e) {
			ErrorProcessor.alert(e.toString());
		}
        setUserName(user);
        setTaskDue(numTasks);
	}
		
	@FXML
    public void initialize() {
    	refreshDate();
    }
	
    /**
	 * Updates the task preview
	 * 
	 * @param title
	 *            title of the preview (i.e. add, delete, edit)
	 * @param taskName
	 *            name of the task to be previewed
	 * @param taskDetails
	 *            details of the task to be previewed
	 * @param taskStart
	 *            start time of the task to be previewed
	 * @param taskEnd
	 *            end time of the task to be previewed
	 */
	public void displayTaskPreview(String title, String taskName, String taskDetails, String taskStart, String taskEnd){
		clearTaskInfo();
		if(title != null){
			createTaskInfoEntry(title, "%s");
		}
		if(taskName != null){
			createTaskInfoEntry(taskName, TASK_NAME_DISPLAY);
		}
		if(taskDetails != null){
			createTaskInfoEntry(taskDetails, TASK_DETAIL_DISPLAY);
		}
		if(taskStart != null){
			createTaskInfoEntry(taskStart, TASK_START_DISPLAY);
		}
		if(taskEnd != null){
			createTaskInfoEntry(taskEnd, TASK_END_DISPLAY);
		}
	}
	
    /**
	 * Adds a preview entry to be displayed
	 * 
	 * @param entry
	 *            text to be displayed
	 * @param stringFormat
	 *            format of the text
	 */
	private void createTaskInfoEntry(String entry, String stringFormat){
		Label label = new Label(String.format(stringFormat, entry));
		label.setMaxWidth(400);
		label.setId("taskDetails");
		taskPreview.getChildren().add(label);
	}
	
	private void clearTaskInfo(){
		taskPreview.getChildren().clear();
	}
	
	private void refreshDate(){
		todayDay.setText(DayProcessor.todayDay());
    	todayDate.setText(DayProcessor.todayDate());
	}	
	
    // ================================================================
    // Setter methods
    // ================================================================
	public void setUserName(String userName){
		this.userName.setText(String.format(WELCOME_MESSAGE, userName));
		refreshDate();
	}
	
	public void setTaskDue(int numTasks){
		numTasksDue.setText(String.format(TASK_DUE_MESSAGE, numTasks));
		refreshDate();
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\controller\MainApp.java
``` java
package controller;

import java.util.List;
import java.util.Optional;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.PopupControl;
import javafx.scene.control.TextInputDialog;
import javafx.scene.image.Image;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import logic.GuiCommand;
import logic.Logic;
import storage.Task;

/**
 * MainApp is the starting point of the application 
 * <p>
 * It initializes the components that the user interacts with  
 *
 * @author Hongchao
 * 
 */
public class MainApp extends Application {
    
    // ================================================================
    // Window Properties
    // ================================================================
	private static final String CSS_PATH = "application.css";
	private static final String ICON_PATH = "img/speedo.png";
	private static final String WINDOW_TITLE = "Spee-Do";
	private static final int WINDOW_WIDTH = 950;
	private static final int WINDOW_HEIGHT = 600;
	
    // ================================================================
    // Dialog box for user's name
    // ================================================================
	private static final String TITLE_TEXT = "Welcome!";
    private static final String HEADER_TEXT = "It seems be your first time here.";
    private static final String CONTENT_TEXT = "Please enter your name:";
    
    // ================================================================
    // Fields
    // ================================================================
    private Logic logic;
	private Stage primaryStage;
	private BorderPane rootLayout;
    private PopupControl helpPopup;
    private TaskListController taskList;
    private CommandBoxController commandBox;
    private InfoPanelController infoPanel;
        
	@Override
	public void start(Stage primaryStage) {
        initRootLayout();
        initHelpBox();
        Scene scene = new Scene(rootLayout, WINDOW_WIDTH, WINDOW_HEIGHT);
		scene.getStylesheets().add(getClass().getResource(CSS_PATH).toExternalForm());
		
		this.primaryStage = primaryStage;
        primaryStage.setTitle(WINDOW_TITLE);
		primaryStage.getIcons().add(new Image(ICON_PATH));
		primaryStage.setScene(scene);
		primaryStage.show();
	}
	
	public static void main(String[] args) {
		launch(args);
	}
	
    /**
     * Initializes the root layout
     * Logic is instantiated here
     * All the controllers will be instantiated here and set as children of rootLayout
     * User will be asked to enter their name here if it is their first time using the application
     */
    private void initRootLayout() {
    	logic = new Logic();
    	
    	rootLayout = new BorderPane();
    	rootLayout.setId("rootLayout");
		
		taskList = new TaskListController();
    	taskList.loadTaskList(logic.getTaskList());
    	rootLayout.setCenter(taskList);
    	
    	commandBox = new CommandBoxController();
    	commandBox.setMainApp(this);
    	rootLayout.setBottom(commandBox);
    	
		promptForUserName();

    	infoPanel = new InfoPanelController(logic.getUser(), taskList.getNumOfTaskDue());
    	rootLayout.setLeft(infoPanel);
    }
        
    // initializes the help box
    private void initHelpBox(){
		helpPopup = new PopupControl();
		helpPopup.setOpacity(1);
		helpPopup.setAutoHide(true);
		helpPopup.getScene().setRoot(new HelpBoxController());
    }
    
    /**
	 * Initializes the dialog box that prompts for the user's name
	 * @return the dialog box 
	 * 
	 */ 
    private TextInputDialog initPromptDialogBox(){
		TextInputDialog dialog = new TextInputDialog("Your Name");
		dialog.setTitle(TITLE_TEXT);
		dialog.setHeaderText(HEADER_TEXT);
		dialog.setContentText(CONTENT_TEXT);
		return dialog;
    }
    
    /**
	 * Prompts the user for their name if it is their first time using the application
	 * A name has to be given in order to continue
	 *  
	 */
    private void promptForUserName(){
    	while(logic.getUser() == null){ 		
    		TextInputDialog dialog = initPromptDialogBox();
    		Optional<String> name = dialog.showAndWait();
    		if (name.isPresent()){
    		    logic.setSettings(name.get(), null);
    		}
    	}
    }
    
    /**
	 * Refresh the InfoPanel and loads a list of Task 
	 * @param listOfTasks
	 *            list of tasks that is to be loaded
	 *            
	 */
    private void refresh(List<Task> listOfTasks){
    	taskList.loadTaskList(listOfTasks);
    	infoPanel.setUserName(logic.getUser());
    	infoPanel.setTaskDue(taskList.getNumOfTaskDue());
    }
	
    /**
	 * Takes in input that the user enters into command box and calls Logic's executeCMD
	 * The GUI will update itself according to the GuiCommand returned 
	 * By default, the GUI will refresh itself and set the feedback message
	 * 
	 * @param userInput
	 *            input that the user enters into command box
	 *            
	 */
    public void handleUserCommand(String userInput) {
        GuiCommand command = logic.executeCMD(userInput);
        switch(command.getCmd()){
	        case HELP: {
	        	displayHelp();
	        }
	        case INVALID: {
	        	commandBox.setErrorFeedback(command.getMsg());
	        	break;
	        } 
	        default: {
	        	commandBox.setFeedback(command.getMsg());
	        	refresh(command.getListOfTasks());
	        	break;
	        }
        }
    }
    
    /**
	 * Takes in input that the user enters into command box and calls Logic's predictCMD
	 * The GUI will dynamically update the InfoPanel and feedback according to what the user is typing
	 * 
	 * @param userInput
	 *            input that the user enters into command box
	 *            
	 */
    public void parseUserCommand(String userInput) {
    	GuiCommand guiCommand = logic.predictCMD(userInput);
    	if(!userInput.equals("")){
    		commandBox.clearFeedback();
    	}
    	commandBox.setPredictionFeedback(guiCommand.getMsg());

    	infoPanel.displayTaskPreview(guiCommand.getTitle(), 
    							  guiCommand.getTaskName(), 
    							  guiCommand.getTaskDetails(), 
    							  guiCommand.getTaskStart(), 
    							  guiCommand.getTaskEnd());
    }
    
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\controller\TaskController.java
``` java
package controller;

import java.io.IOException;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import storage.Task;
import utilities.ErrorProcessor;

/**
 * TaskController controls how each individual task is displayed
 * <p>
 * A user can click on any task to open up a drop-down with the task details
 * There are no getter methods in this class, as there is no need to access any of the fields in the class
 * TaskController is usually reloaded after each user command when the task list gets refreshed in MainApp,
 * hence there is no instance where we have to access each individual task 
 * 
 *  @author Hongchao
 *
 */
public class TaskController extends TitledPane{
	
	// ================================================================
    // FXML
    // ================================================================
	private static final String FXML_PATH = "/view/TaskView.fxml";
	
	@FXML 
	private VBox expandedBox;
	
	@FXML 
	private HBox details;
	@FXML 
	private HBox endDate;
	@FXML 
	private HBox startDate;
	
	@FXML 
	private Label detailsLabel;
	@FXML 
	private Label startDateLabel;
	@FXML 
	private Label endDateLabel;
	
	@FXML 
	private Text detailsText;
	@FXML 
	private Text startDateText;
	@FXML 
	private Text endDateText;
	
	// ================================================================
    // Format of task name displayed
    // ================================================================
	private static final String TASK_NAME_DISPLAY = "%d. %s";
	
	// ================================================================
    // Fields
    // ================================================================
	private int taskIndex;
	
	public TaskController(Task task, int index){
		try {
        	FXMLLoader loader = new FXMLLoader();
            loader.setLocation(getClass().getResource(FXML_PATH));
            loader.setRoot(this);
            loader.setController(this);
        	loader.load();
		} catch (IOException e) {
			ErrorProcessor.alert(e.toString());
		}
        initTask(task, index);
	}
	
	@FXML
    public void initialize() {
        this.setExpanded(false);
    }
	
	/**
	 * Initializes a TaskController instance according to the Task object provided
	 * 
	 * @param task
	 *            task which the TaskController is modeled after
	 * @param index
	 *            index of the task
	 */
	private void initTask(Task task, int index){
    	setTaskIndex(index);
		setName(task.getName());
        setDetails(task.getDetails());
        setStartDate(task.getStartDateString());
        setEndDate(task.getEndDateString()); 
        applyStyling(task);
	}
	
	/**
	 * Checks the type of task and applies the relevant styling to it's corresponding TaskController
	 * 
	 * @param task
	 *            task that the style is applied to
	 */
	private void applyStyling(Task task){
        if(task.isCompleted()){
        	this.setId("taskCompleted");
        	this.setOpacity(0.2);
        } else if(task.due() == Task.OVERDUE){
        	this.setId("taskOverdue");
        } else if(task.due() == Task.TODAY){
        	this.setId("taskDueToday");
        } else if(task.due() == Task.TOMORROW){
        	this.setId("taskDueTomorrow");
        } else if(task.due() == Task.NODATE){
        	this.setId("taskToDo");
        	if(task.getDetails() == null){
        		this.setCollapsible(false);
        	}
        	expandedBox.getChildren().remove(endDate);
        }
	}
	
	// ================================================================
    // Setter methods
    // ================================================================
	
	private void setName(String name){
		this.setText(String.format(TASK_NAME_DISPLAY, taskIndex, name));
	}
	
	private void setDetails(String text){
		if(text == null){
			expandedBox.getChildren().remove(details);
		} else {
			detailsText.setText(text);
		}
	}
	
	/**
	 * When there is no start date, the start date label is removed and the end date label is 
	 * renamed to "Date"
	 */
	private void setStartDate(String date){
		if(date == null){
			expandedBox.getChildren().remove(startDate);
			endDateLabel.setText("Date");
		} else {
			startDateText.setText(date);
		}
	}
	
	private void setEndDate(String date){
		endDateText.setText(date);
	}
			
	private void setTaskIndex(int index){
		taskIndex = index;
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\controller\TaskListController.java
``` java
package controller;

import java.io.IOException;
import java.util.List;

import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.VBox;
import storage.Task;
import utilities.ErrorProcessor;

/**
 * TaskListController manages the display of the list of user Task(s) 
 * <p>
 * The user can scroll vertically when the number of tasks to display is larger than the display area 
 * Scrolling horizontally can only be done with keyboard and is only allowed when the Task has a 
 * name that exceeds the display
 *
 * @author Hongchao
 *
 */

public class TaskListController extends ScrollPane {

	// ================================================================
	// FXML
	// ================================================================
	private static final String FXML_PATH = "/view/TaskListView.fxml";
	@FXML
	private VBox containerOfTask;

	// ================================================================
	// Task labels
	// ================================================================
	private static final String NODATE_LABEL = "TO-DO's";
	private static final String OVERDUE_LABEL = "OVERDUE";
	private static final String TODAY_LABEL = "TODAY";
	private static final String TOMORROW_LABEL = "TOMORROW";
	private static final String UPCOMING_LABEL = "UPCOMING";

	// ================================================================
	// Fields
	// ================================================================
	private ObservableList<Node> listOfTask;
	private boolean[] isTaskType;
	private int numOfTaskDue;

	public TaskListController() {
		try {
			FXMLLoader loader = new FXMLLoader();
			loader.setLocation(getClass().getResource(FXML_PATH));
			loader.setRoot(this);
			loader.setController(this);
			loader.load();
		} catch (IOException e) {
			ErrorProcessor.alert(e.toString());
		}
	}

	@FXML
	public void initialize() {
		listOfTask = containerOfTask.getChildren();
		// prevents the user from scrolling left and right using the mouse
		this.addEventFilter(ScrollEvent.SCROLL, new EventHandler<ScrollEvent>() {
			@Override
			public void handle(ScrollEvent event) {
				if (event.getDeltaX() != 0) {
					event.consume();
				}
			}
		});
	}

	/**
	 * Loads a list of task(s) to display The number of task(s) due will be
	 * reset If there is any old list, it will be deleted Labels will be added
	 * here to act as sections between the different types of task
	 * 
	 * @param list
	 *            list of task(s) that is to be loaded
	 */
	public void loadTaskList(List<Task> list) {
		numOfTaskDue = 0;
		isTaskType = new boolean[6];
		listOfTask.clear();
		if (list != null) {
			for (int i = 0; i < list.size(); i++) {
				generateLabel(list.get(i));
				addTask(list.get(i), i + 1);
			}
		}
	}

	/**
	 * Adds the task to the task list and appends the given index to its name
	 * The number of task(s) due is calculated here
	 * 
	 * @param task
	 *            task to be added
	 * @param index
	 *            task index to be displayed
	 */
	private void addTask(Task task, int index) {
		listOfTask.add(new TaskController(task, index));
		if (task.due() == Task.TODAY && !task.isCompleted()) {
			numOfTaskDue++;
		}
	}

	/**
	 * Checks if a task of particular type exists in the list If false, a label
	 * will be added Otherwise, no label will be added
	 * 
	 * @param task
	 *            task to be checked
	 */
	private void generateLabel(Task task) {
		if (task.due() == Task.NODATE && !isTaskType[Task.NODATE]) {
			addLabel(NODATE_LABEL, Task.NODATE);
		} else if (task.due() == Task.OVERDUE && !isTaskType[Task.OVERDUE]) {
			addLabel(OVERDUE_LABEL, Task.OVERDUE);
		} else if (task.due() == Task.TODAY && !isTaskType[Task.TODAY]) {
			addLabel(TODAY_LABEL, Task.TODAY);
		} else if (task.due() == Task.TOMORROW && !isTaskType[Task.TOMORROW]) {
			addLabel(TOMORROW_LABEL, Task.TOMORROW);
		} else if (task.due() == Task.UPCOMING && !isTaskType[Task.UPCOMING]) {
			addLabel(UPCOMING_LABEL, Task.UPCOMING);
		}
	}

	/**
	 * Adds a label
	 * 
	 * @param title
	 *            the text to display in the label
	 * @param taskType
	 *            enum of the type of task
	 */
	private void addLabel(String title, int taskType) {
		Label label = new Label(title);
		containerOfTask.getChildren().add(label);
		isTaskType[taskType] = true;
	}

	// ================================================================
	// Getter methods
	// ================================================================
	public int getNumOfTaskDue() {
		return numOfTaskDue;
	}

	/**
	 * The methods below are no longer in use, as the TaskListController is
	 * usually refreshed after each user command
	 */

	// ================================================================
	// Depreciated methods
	// ================================================================

	/*
	 * private void addTask(Task t){ addTask(t, listOfTask.size()); }
	 * 
	 * public void removeTask(Task t){ TaskController tc =
	 * taskLookupTable.get(t.getTaskId()); listOfTask.remove(tc);
	 * taskLookupTable.remove(t.getTaskId()); }
	 * 
	 * public void editTask(Task t){ TaskController tc =
	 * taskLookupTable.get(t.getTaskId()); tc.setName(t.getName()); }
	 */
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\junitTests\PredictiveTest.java
``` java
package junitTests;

import static org.junit.Assert.*;
import org.junit.Test;
import logic.GuiCommand;
import logic.Logic;
import parser.Predictive;
import utilities.COMMANDS;

public class PredictiveTest {
	
	private static final String ADD_MSG = "Adding Task...";
	private static final String EDIT_MSG = "Editing Task...";
	private static final String DELETE_MSG = "Delete Task?";
	
	private static final String RANDOM_INPUT = "fjdfkdlj jdlkjdskfj   dssdsdd 	jsljlkasjdlkajdslk";
	private static final String RANDOM_WITH_SYMBOLS_INPUT = "!@#$%^&*()_-+ -d -i";
	
	private static final String ADD_WITHOUT_NAME_INPUT = "add";
	private static final String INSERT_WITHOUT_NAME_INPUT = "insert";
	private static final String ADD_NAME_ONLY_INPUT = "add some Task";
	private static final String INSERT_NAME_ENDDATE_INPUT = "insert some Task -d 30 nov 2013";
	private static final String INSERT_NAME_ENDDATE_STARTDATE_INPUT = "insert some Task -d 30 nov 2013 31 jan 2012";
	private static final String ADD_NAME_STARTDATE_ENDDATE_INPUT = "insert task123 -d 4 nov 2013 0930 4 nov 2015 2359";
	private static final String ADD_NAME_STARTDATE_ENDDATE_INFO_INPUT = "insert task123 -d 10 nov 2013 30 nov 2015 -i this is some info";
	
	private static final String EDIT_WITHOUT_INDEX_INPUT = "edit";
	private static final String CHANGE_WITHOUT_INDEX_INPUT = "change";
	private static final String EDIT_WITH_INVALID_INDEX_INPUT = "edit -2 new name";
	private static final String CHANGE_WITH_INVALID_INDEX_INPUT = "change fdfdjskljfklsdjf";
	private static final String EDIT_WITH_NOCHANGE_INPUT = "edit 1";
	private static final String CHANGE_NAME_ONLY_INPUT = "change 1 hello";
	private static final String EDIT_NAME_ENDDATE_INPUT = "edit 3 bye -d 10 jan 2099";
	private static final String CHANGE_NAME_STARTDATE_ENDDATE_INPUT = "change 3 new name -d 15 nov 2015 0800 15 nov 2015 2359";
	private static final String EDIT_NAME_ENDDATE_STARTDATE_INFO_INPUT = "edit 3 new name -d 15 nov 2015 2359 15 nov 2015 0800 -i edited info for task 3...";
	
	private static final String DELETE_WITHOUT_INDEX_INPUT = "delete";
	private static final String REMOVE_WITHOUT_INDEX_INPUT = "remove";
	private static final String DELETE_WITH_INVALID_INDEX_INPUT = "delete -2";
	private static final String REMOVE_WITH_INVALID_INDEX_INPUT = "remove jlksdjlkajkl";
	private static final String DELETE_WITH_VALID_INDEX_INPUT = "delete 2";
	
	private static final String ADD_FLOATING_TASK_INPUT = "add Task 1";
	private static final String ADD_TASK_WITH_ENDDATE_INPUT = "add Task 2 -d 10 jul 2018 1200";
	private static final String ADD_TASK_WITH_STARTDATE_ENDDATE_INFO_INPUT = "add Task 3 -d 10 jul 2018 20 feb 2020 -i task 3 info...";
	
	private Logic initLogic(){
		Logic logic = new Logic(true);
		logic.executeCMD(ADD_FLOATING_TASK_INPUT);
		logic.executeCMD(ADD_TASK_WITH_ENDDATE_INPUT);
		logic.executeCMD(ADD_TASK_WITH_STARTDATE_ENDDATE_INFO_INPUT);
		return logic;
	}
	
	@Test
	public void testEmptyInput() {
		Predictive predictor = new Predictive();
		predictor.processInput("");
		assertEquals(predictor.getCommand(), COMMANDS.INVALID);
		assertEquals(predictor.getCommandMsg(), null);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), null);
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), null);
		assertEquals(predictor.getTaskEnd(), null);
	}
	
	@Test
	public void testRandomInput(){
		Predictive predictor = new Predictive();
		predictor.processInput(RANDOM_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.INVALID);
		assertEquals(predictor.getCommandMsg(), null);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), null);
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), null);
		assertEquals(predictor.getTaskEnd(), null);
	}
	
	@Test
	public void testRandomInputWithSymbols(){
		Predictive predictor = new Predictive();
		predictor.processInput(RANDOM_WITH_SYMBOLS_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.INVALID);
		assertEquals(predictor.getCommandMsg(), null);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), null);
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), null);
		assertEquals(predictor.getTaskEnd(), null);
	}
	
	@Test
	public void testAddWithoutName() {
		Predictive predictor = new Predictive();
		predictor.processInput(ADD_WITHOUT_NAME_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.ADD);
		assertEquals(predictor.getCommandMsg(), ADD_MSG);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), null);
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), null);
		assertEquals(predictor.getTaskEnd(), null);
	}
	
	@Test
	public void testInsertWithoutName() {
		Predictive predictor = new Predictive();
		predictor.processInput(INSERT_WITHOUT_NAME_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.ADD);
		assertEquals(predictor.getCommandMsg(), ADD_MSG);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), null);
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), null);
		assertEquals(predictor.getTaskEnd(), null);
	}
	
	@Test
	public void testAddWithNameOnly() {
		Predictive predictor = new Predictive();
		predictor.processInput(ADD_NAME_ONLY_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.ADD);
		assertEquals(predictor.getCommandMsg(), ADD_MSG);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), "some Task");
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), null);
		assertEquals(predictor.getTaskEnd(), null);
	}
	
	@Test
	public void testInsertWithNameEndDate() {
		Predictive predictor = new Predictive();
		predictor.processInput(INSERT_NAME_ENDDATE_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.ADD);
		assertEquals(predictor.getCommandMsg(), ADD_MSG);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), "some Task");
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), null);
		assertEquals(predictor.getTaskEnd(), "30 November 2013 12:00 AM");
	}
	
	@Test
	public void testInsertWithNameEndStartDate() {
		Predictive predictor = new Predictive();
		predictor.processInput(INSERT_NAME_ENDDATE_STARTDATE_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.ADD);
		assertEquals(predictor.getCommandMsg(), ADD_MSG);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), "some Task");
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), "31 January 2012 12:00 AM");
		assertEquals(predictor.getTaskEnd(), "30 November 2013 12:00 AM");
	}
	
	@Test
	public void testAddWithNameStartEndDate() {
		Predictive predictor = new Predictive();
		predictor.processInput(ADD_NAME_STARTDATE_ENDDATE_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.ADD);
		assertEquals(predictor.getCommandMsg(), ADD_MSG);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), "task123");
		assertEquals(predictor.getTaskDetails(), null);
		assertEquals(predictor.getTaskStart(), "04 November 2013 09:30 AM");
		assertEquals(predictor.getTaskEnd(), "04 November 2015 11:59 PM");
	}
	
	@Test
	public void testAddWithNameStartEndDateInfo() {
		Predictive predictor = new Predictive();
		predictor.processInput(ADD_NAME_STARTDATE_ENDDATE_INFO_INPUT);
		assertEquals(predictor.getCommand(), COMMANDS.ADD);
		assertEquals(predictor.getCommandMsg(), ADD_MSG);
		assertEquals(predictor.getIndex(), -1);
		assertEquals(predictor.getTaskName(), "task123");
		assertEquals(predictor.getTaskDetails(), "this is some info");
		assertEquals(predictor.getTaskStart(), "10 November 2013 12:00 AM");
		assertEquals(predictor.getTaskEnd(), "30 November 2015 12:00 AM");
	}
	
	@Test
	public void editWithoutIndex() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(EDIT_WITHOUT_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), null);
		assertEquals(commandToGui.getTaskName(), null);
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void changeWithoutIndex() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(CHANGE_WITHOUT_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), null);
		assertEquals(commandToGui.getTaskName(), null);
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void editWithInvalidIndex() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(EDIT_WITH_INVALID_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), null);
		assertEquals(commandToGui.getTaskName(), null);
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void changeWithInvalidIndex() {
		Logic logic = initLogic();		
		GuiCommand commandToGui = logic.predictCMD(CHANGE_WITH_INVALID_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), null);
		assertEquals(commandToGui.getTaskName(), null);
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void editWithNoChange() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(EDIT_WITH_NOCHANGE_INPUT);
		assertEquals(commandToGui.getTitle(), EDIT_MSG);
		assertEquals(commandToGui.getTaskName(), "Task 1");
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void changeNameOnly() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(CHANGE_NAME_ONLY_INPUT);
		assertEquals(commandToGui.getTitle(), EDIT_MSG);
		assertEquals(commandToGui.getTaskName(), "hello");
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void editNameEndDate() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(EDIT_NAME_ENDDATE_INPUT);
		assertEquals(commandToGui.getTitle(), EDIT_MSG);
		assertEquals(commandToGui.getTaskName(), "bye");
		assertEquals(commandToGui.getTaskDetails(), "task 3 info...");
		assertEquals(commandToGui.getTaskStart(), "10 July 2018 12:00 AM");
		assertEquals(commandToGui.getTaskEnd(), "10 January 2099 12:00 AM");
	}
	
	@Test
	public void changeNameStartEndDate() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(CHANGE_NAME_STARTDATE_ENDDATE_INPUT);
		assertEquals(commandToGui.getTitle(), EDIT_MSG);
		assertEquals(commandToGui.getTaskName(), "new name");
		assertEquals(commandToGui.getTaskDetails(), "task 3 info...");
		assertEquals(commandToGui.getTaskStart(), "15 November 2015 08:00 AM");
		assertEquals(commandToGui.getTaskEnd(), "15 November 2015 11:59 PM");
	}
	
	@Test
	public void editNameEndStartDate() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(EDIT_NAME_ENDDATE_STARTDATE_INFO_INPUT);
		assertEquals(commandToGui.getTitle(), EDIT_MSG);
		assertEquals(commandToGui.getTaskName(), "new name");
		assertEquals(commandToGui.getTaskDetails(), "edited info for task 3...");
		assertEquals(commandToGui.getTaskStart(), "15 November 2015 08:00 AM");
		assertEquals(commandToGui.getTaskEnd(), "15 November 2015 11:59 PM");
	}
	
	@Test
	public void deleteWithoutIndex() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(DELETE_WITHOUT_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), null);
		assertEquals(commandToGui.getTaskName(), null);
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void removeWithoutIndex() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(REMOVE_WITHOUT_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), null);
		assertEquals(commandToGui.getTaskName(), null);
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void deleteWithInvalidIndex() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(DELETE_WITH_INVALID_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), null);
		assertEquals(commandToGui.getTaskName(), null);
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void removeWithInvalidIndex() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(REMOVE_WITH_INVALID_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), null);
		assertEquals(commandToGui.getTaskName(), null);
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), null);
	}
	
	@Test
	public void deleteWithValidIndex() {
		Logic logic = initLogic();
		GuiCommand commandToGui = logic.predictCMD(DELETE_WITH_VALID_INDEX_INPUT);
		assertEquals(commandToGui.getTitle(), DELETE_MSG);
		assertEquals(commandToGui.getTaskName(), "Task 2");
		assertEquals(commandToGui.getTaskDetails(), null);
		assertEquals(commandToGui.getTaskStart(), null);
		assertEquals(commandToGui.getTaskEnd(), "10 July 2018 12:00 AM");
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\logic\Logic.java
``` java
	public GuiCommand predictCMD(String input) {
		String message = predictor.processInput(input);
		GuiCommand guiCommand = new GuiCommand(null, message);
		int index = predictor.getIndex();

		switch (predictor.getCommand()) {
		case ADD:
			guiCommand.setTitle(predictor.getCommandMsg());
			guiCommand.setTaskName(predictor.getTaskName());
			guiCommand.setTaskDetails(predictor.getTaskDetails());
			guiCommand.setTaskStart(DayProcessor.formatDate(predictor.getTaskStart()));
			guiCommand.setTaskEnd(DayProcessor.formatDate(predictor.getTaskEnd()));
			break;
		case DELETE:
			if (index != -1 && index < store.getTaskList().size()) {
				guiCommand.setTitle(predictor.getCommandMsg());
				Task task = store.getTaskList().get(index);
				guiCommand.setTaskName(task.getName());
				guiCommand.setTaskDetails(task.getDetails());
				guiCommand.setTaskStart(task.getStartDateString());
				guiCommand.setTaskEnd(task.getEndDateString());
			}
			break;
		case EDIT:
			if (index != -1 && index < store.getTaskList().size()) {
				guiCommand.setTitle(predictor.getCommandMsg());
				Task task = store.getTaskList().get(index);
				if (predictor.getTaskName() != null) {
					guiCommand.setTaskName(predictor.getTaskName());
				} else {
					guiCommand.setTaskName(task.getName());
				}

				if (predictor.getTaskDetails() != null) {
					guiCommand.setTaskDetails(predictor.getTaskDetails());
				} else {
					guiCommand.setTaskDetails(task.getDetails());
				}

				Date startDate;
				Date endDate;
				if (predictor.getTaskStart() != null) {
					startDate = predictor.getTaskStart();
				} else {
					startDate = task.getStartDate();
				}

				if (predictor.getTaskEnd() != null) {
					endDate = predictor.getTaskEnd();
				} else {
					endDate = task.getEndDate();
				}
				DatePair orderedDate = DayProcessor.orderDate(startDate, endDate);
				guiCommand.setTaskStart(DayProcessor.formatDate(orderedDate.getDateOne()));
				guiCommand.setTaskEnd(DayProcessor.formatDate(orderedDate.getDateTwo()));
			}
			break;
		default:
			break;
		}
		return guiCommand;
	}

```
