# A0125369Y
###### C:\Users\Barnabas\Documents\GitHub\main\src\controller\MainApp.java
``` java
    private void displayHelp(){
    	helpPopup.show(primaryStage);	
    	helpPopup.setX(primaryStage.getX() + primaryStage.getWidth() / 2 - helpPopup.getWidth() / 2);
    	helpPopup.setY(primaryStage.getY() + primaryStage.getHeight() / 2 - helpPopup.getHeight() / 2);
    }        
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\junitTests\StorageTest.java
``` java
package junitTests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import org.junit.Test;

import storage.Storage;
import storage.Task;

public class StorageTest {
	//private static Storage store = new Storage(true);
	//private static Task task;

	@Test
	public void testAdd() {

		Storage store = new Storage(true);
		
		// Adding as usual
		Date date = new Date();
		String name = "test";
		String details = "task details";
		String taskName = store.add(name, details, null, date);
		assertEquals(name, taskName); 

		// Checking other variables
		List<Task> taskList = store.getTaskList();
		assertEquals(details, taskList.get(0).getDetails());
		assertEquals(date, taskList.get(0).getEndDate());
		
		// Duplicated task
		String duplicate = store.add(name, details, null, date);
		assertEquals(null, duplicate); 
	}

	@Test
	public void testDelete() {
		Storage store = new Storage(true);
		assert store.getTaskList().isEmpty();
		
		// Adding as usual
		Date date = new Date();
		String name = "test";
		String details = "task details";
		String taskName = store.add(name, details, null, date);
		
		assertEquals(taskName, store.delete(0));
	}

	@Test
	public void testUndoDelete() {
		Storage store = new Storage(true);
		assert store.getTaskList().isEmpty();
		
		// Adding as usual
		Date date = new Date();
		String name = "test";
		String details = "task details";
		
		// Assume that add and delete are working
		store.add(name, details, null, date);
		store.delete(0);
		
		assertEquals(name, store.undo());
	}

	@Test
	public void testEdit() {
		Storage store = new Storage(true);
		
		// Adding as usual
		Date date = new Date();
		String name = "test";
		String details = "task details";
		
		// Assume that add is working
		store.add(name, details, null, date);
		
		String newName = "new test";
		store.edit(0, newName, null, null, null);
		String editedName = store.getTaskList().get(0).getName();
		assertEquals(newName, editedName);
	}
	
	@Test
	public void testUndoEdit() {
		Storage store = new Storage(true);
		
		// Adding as usual
		Date date = new Date();
		String name = "test";
		String details = "task details";
		String taskName = store.add(name, details, null, date);
		String newName = "new test";
		
		// Assume that edit and undo are working
		store.edit(0, newName, null, null, null);
		store.undo();
		
		assertEquals(taskName, store.getTaskList().get(0).getName());
	}
	
	@Test
	public void testComplete() {
		Storage store = new Storage(true);
		
		// Adding as usual
		Date date = new Date();
		String name = "test";
		String details = "task details";
		
		// Assume that add is working
		String taskName = store.add(name, details, null, date);
		
		assertEquals(taskName, store.complete(0));
		assertEquals(true, store.getCompletedList().get(0).isCompleted());
	}

	@Test
	public void testSearch() throws ParseException {
		Storage store = new Storage(true);
		// Adding more entries
		String name;
		String details;
		Date date;

		SimpleDateFormat sdf = new SimpleDateFormat("dd-M-yyyy hh:mm");
		String dateInString = "28-09-2015 08:00";
		date = sdf.parse(dateInString);
		name = "test 2";
		details = "this is test 2";
		store.add(name, details, null, date);

		sdf = new SimpleDateFormat("dd-M-yyyy hh:mm");
		dateInString = "21-10-2015 02:00";
		date = sdf.parse(dateInString);
		name = "Sleep";
		details = "Get sleep to prepare for tutorial";
		store.add(name, details, null, date);

		sdf = new SimpleDateFormat("dd-M-yyyy hh:mm");
		dateInString = "24-10-2015 02:00";
		date = sdf.parse(dateInString);
		name = "2103 Meeting";
		details = "Get more coding done before 2010 written & online quiz";
		store.add(name, details, null, date);

		List<Task> searchList = store.search("2103");
		for (Task task : searchList) {
			System.out.println(task);
		}
		assertEquals(name, searchList.get(0).getName());

		searchList = store.search("Get");
		for (Task task : searchList) {
			System.out.println(task);
		}
		assertEquals("Sleep", searchList.get(0).getName());
		
		searchList = store.search("Apples");
		for (Task task : searchList) {
			System.out.println(task);
		}
		assertEquals(0, searchList.size());
		
		searchList = store.search("october");
		for (Task task : searchList) {
			System.out.println(task);
		}
		assertEquals(2, searchList.size());
	}



	@Test
	public void testValidIndex() {
		// Assumes that Add, Undo, Delete, Edit works 
		
		Storage store = new Storage(true);
		// Testing index via boundaries
		Date date = new Date();
		String name = "test 1";
		String details = "this is test 1";
		store.add(name, details, null, date);

		date = new Date();
		name = "test 2";
		details = "this is test 2";
		store.add(name, details, null, date);

		date = new Date();
		name = "test 3";
		details = "this is test 3";
		store.add(name, details, null, date);
		for (Task task : store.getTaskList()) {
			System.out.println(task);
		}
		assertEquals(null, store.delete(-1));
		assertNotEquals(null, store.delete(0));
		store.undo();
		assertNotEquals(null, store.delete(2));
		store.undo();
		assertEquals(null, store.delete(3));

		String newName = "new test";
		assertEquals(null, store.edit(-1, newName, null, null, null));
		assertNotEquals(null, store.edit(0, newName, null, null, null));
		assertNotEquals(null, store.edit(2, newName, null, null, null));
		assertEquals(null, store.edit(3, newName, null, null, null));
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\parser\DateParser.java
``` java
package parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import utilities.DatePair;

public class DateParser {
	private static SimpleDateFormat dateStringMth;
	private static SimpleDateFormat dateIntMth;
	private static SimpleDateFormat dateStringMthTime;
	private static SimpleDateFormat dateIntMthTime;
	//private static SimpleDateFormat dateStringMthTimeShort;
	//private static SimpleDateFormat dateIntMthTimeShort;

	/*
	private static final String JAN_STRING = "jan january";
	private static final String FEB_STRING = "feb february";
	private static final String MAR_STRING = "mar march";
	private static final String APR_STRING = "apr april";
	private static final String MAY_STRING = "may may";
	private static final String JUN_STRING = "jun june";
	private static final String JUL_STRING = "jul july";
	private static final String AUG_STRING = "aug august";
	private static final String SEP_STRING = "sep september";
	private static final String OCT_STRING = "oct october";
	private static final String NOV_STRING = "nov november";
	private static final String DEC_STRING = "dec december";

	private static final String JAN_INT = "01";
	private static final String FEB_INT = "02";
	private static final String MAR_INT = "03";
	private static final String APR_INT = "04";
	private static final String MAY_INT = "05";
	private static final String JUN_INT = "06";
	private static final String JUL_INT = "07";
	private static final String AUG_INT = "08";
	private static final String SEP_INT = "09";
	private static final String OCT_INT = "10";
	private static final String NOV_INT = "11";
	private static final String DEC_INT = "12";
	*/

	private static final String DATE_STRING_MONTH = "ddMMMMyyyy";
	private static final String DATE_INT_MONTH = "ddMMyyyy";
	private static final String DATE_STRING_MONTH_TIME = "ddMMMMyyyy hhmm";
	private static final String DATE_INT_MONTH_TIME = "ddMMyyyy hhmm";
	//private static final String DATE_STRING_MONTH_TIME_SHORT = "ddMMMMyy hhmm";
	//private static final String DATE_INT_MONTH_TIME_SHORT = "ddMMyy hhmm";

	private static final String SPACE = " ";

	// Index of various date components
	private static final int DAY = 0;
	private static final int MTH1 = 1;
	private static final int YR2 = 2;

	private static final int DAY4 = 4;
	private static final int MTH5 = 5;
	private static final int YR6 = 6;

	private static final int DAY1 = 1;
	private static final int MTH2 = 2;
	private static final int YR3 = 3;

	private static final int DAY2 = 2;
	private static final int MTH3 = 3;
	private static final int YR4 = 4;

	private static final int DAY3 = 3;
	private static final int MTH4 = 4;
	private static final int YR5 = 5;

	private static final int DATE = 0;
	private static final int DATE1 = 1;
	private static final int DATE2 = 2;
	private static final int DATE3 = 3;
	private static final int DATE4 = 4;

	private static final int TIME1 = 1;
	private static final int TIME3 = 3;
	private static final int TIME4 = 4;
	private static final int TIME5 = 5;
	private static final int TIME6 = 6;
	private static final int TIME7 = 7;

	// Length of strings
	private static final int DATE_LEN = 6;
	private static final int TIME_LEN = 4;
	private static final int DAY_LEN = 2;
	private static final int YEAR_LEN = 4;

	/**
	 * Method to process a string of 2 or less dates
	 * 
	 * The following formats will be processed
	 * <p>
	 * 
	 * <ul>
	 * Date:
	 * <li><b>dd-MM-yyyy</b> E.g. 27-12-2015</li>
	 * <li><b>dd/MM/yyyy</b> E.g. 27/12/2015</li>
	 * <li><b>dd MM yyyy</b> E.g. 27 12 2015</li>
	 * </ul>
	 * <ul>
	 * Time:
	 * <li><b>hh:mm</b> E.g. 08:00</li>
	 * <li><b>hhmm</b> E.g. 0800</li>
	 * </ul>
	 * 
	 * @param dateText
	 *            string containing 2 or less dates
	 * 
	 * @return DatePair object holding two dates
	 */
	public static DatePair stringToDate(String dateText) {
		/*
		 * TODO |12 Hour Format|: hh:mm am/pm e.g. 08:00 pm hhmm e.g. 0800 pm
		 * 
		 */

		dateStringMth = new SimpleDateFormat(DATE_STRING_MONTH);
		dateIntMth = new SimpleDateFormat(DATE_INT_MONTH);
		dateStringMthTime = new SimpleDateFormat(DATE_STRING_MONTH_TIME);
		dateIntMthTime = new SimpleDateFormat(DATE_INT_MONTH_TIME);
		//dateStringMthTimeShort = new SimpleDateFormat(DATE_STRING_MONTH_TIME_SHORT);
		//dateIntMthTimeShort = new SimpleDateFormat(DATE_INT_MONTH_TIME_SHORT);

		dateText = dateText.trim().replaceAll(" +", " ");
		String[] pieces = dateText.split(" ");

		Date dateOne = null;
		Date dateTwo = null;

		String stringDateOne = "";
		String stringDateTwo = "";

		if (pieces.length == 8) {
			// Length 8: two dates with spaces E.g. 12 oct 2015 08:00
			stringDateOne = pieces[DAY] + pieces[MTH1] + pieces[YR2] + SPACE + pieces[TIME3];
			stringDateTwo = pieces[DAY4] + pieces[MTH5] + pieces[YR6] + SPACE + pieces[TIME7];
		} else if (pieces.length == 7) {
			if (pieces[TIME3].length() >= TIME_LEN && pieces[DAY4].length() <= DAY_LEN) {
				// Length 7: Mixture, date with spaces with time first & date with spaces without time second
				stringDateOne = pieces[DAY] + pieces[MTH1] + pieces[YR2] + SPACE + pieces[TIME3];
				stringDateTwo = pieces[DAY4] + pieces[MTH5] + pieces[YR6];
			} else if (pieces[YR5].length() >= YEAR_LEN && pieces[TIME6].length() >= TIME_LEN) {
				// Length 7: Mixture, date with spaces with time second & date with spaces without time first
				stringDateOne = pieces[DAY] + pieces[MTH1] + pieces[YR2];
				stringDateTwo = pieces[DAY3] + pieces[MTH4] + pieces[YR5] + SPACE + pieces[TIME6];
			}
		} else if (pieces.length == 6) {
			if (pieces[DATE].length() >= DATE_LEN) {
				// Length 6: Mixture, date without spaces with time first & date with spaces with time second
				stringDateOne = pieces[DATE] + SPACE + pieces[TIME1];
				stringDateTwo = pieces[DAY2] + pieces[MTH3] + pieces[YR4] + SPACE + pieces[TIME5];
			} else if (pieces[DATE4].length() >= DATE_LEN) {
				// Length 6: Mixture, date without spaces with time second & date with spaces with time first
				stringDateOne = pieces[DAY] + pieces[MTH1] + pieces[YR2] + SPACE + pieces[TIME3];
				stringDateTwo = pieces[DATE4] + SPACE + pieces[TIME5];
			} else {
				// Length 6: Two dates with spaces without time
				stringDateOne = pieces[DAY] + pieces[MTH1] + pieces[YR2];
				stringDateTwo = pieces[DAY3] + pieces[MTH4] + pieces[YR5];
			}
		} else if (pieces.length == 5) {
			if (pieces[DATE].length() >= DATE_LEN && pieces[TIME4].length() >= TIME_LEN) {
				// Length 5: Mixture, date with spaces with time second & date
				// without spaces without time first
				stringDateOne = pieces[DATE];
				stringDateTwo = pieces[DAY1] + pieces[MTH2] + pieces[YR3] + SPACE + pieces[TIME4];
			} else if (pieces[DATE4].length() >= DATE_LEN && pieces[3].length() >= TIME_LEN) {
				// Length 5: Mixture, date with spaces with time first & without
				// spaces without time second
				stringDateOne = pieces[DAY] + pieces[MTH1] + pieces[YR2] + SPACE + pieces[TIME3];
				stringDateTwo = pieces[DATE4];
			} else if (pieces[DATE].length() >= DATE_LEN && pieces[TIME1].length() >= TIME_LEN) {
				// Length 5: Mixture, date with spaces without time second &
				// date without spaces with time first
				stringDateOne = pieces[DATE] + SPACE + pieces[TIME1];
				stringDateTwo = pieces[DAY2] + pieces[MTH3] + pieces[YR4];
			} else if (pieces[DATE3].length() >= DATE_LEN && pieces[4].length() >= TIME_LEN) {
				// Length 5: Mixture, date with spaces without time first & date
				// without spaces with time second
				stringDateOne = pieces[DAY] + pieces[MTH1] + pieces[YR2];
				stringDateTwo = pieces[DATE3] + SPACE + pieces[TIME4];
			}
		} else if (pieces.length == 4) {
			if (pieces[DATE].length() >= DATE_LEN && pieces[DATE2].length() >= DATE_LEN) {
				// Length 4: Two dates with time
				stringDateOne = pieces[DATE] + SPACE + pieces[TIME1];
				stringDateTwo = pieces[DATE2] + SPACE + pieces[TIME3];
			} else if (pieces[DATE].length() >= DATE_LEN && pieces[DAY1].length() <= DAY_LEN) {
				// Length 4: Mixture, date without spaces first & date with
				// spaces second, both without time
				stringDateOne = pieces[DATE];
				stringDateTwo = pieces[DAY1] + pieces[MTH2] + pieces[YR3];
			} else if (pieces[DAY].length() <= DAY_LEN && pieces[DATE3].length() >= DATE_LEN) {
				// Length 4: Mixture, date without spaces second & date with
				// spaces first, both without time
				stringDateOne = pieces[DAY] + pieces[MTH1] + pieces[YR2];
				stringDateTwo = pieces[DATE3];
			} else {
				// Length 4: One date with spaces with time
				stringDateTwo = pieces[DAY] + pieces[MTH1] + pieces[YR2] + SPACE + pieces[TIME3];
			}
		} else if (pieces.length == 3) {
			// Length 3: One date with spaces
			stringDateTwo = pieces[DAY] + pieces[MTH1] + pieces[YR2];

		} else if (pieces.length == 2) {
			if (pieces[DATE].length() >= DATE_LEN && pieces[DATE1].length() >= DATE_LEN) {
				// Length 2: Two dates without spaces without time
				stringDateOne = pieces[DATE];
				stringDateTwo = pieces[DATE1];
			} else {
				// Length 2: One date without spaces with time
				stringDateTwo = pieces[DATE] + SPACE + pieces[TIME1];
			}
		} else if (pieces.length == 1) {
			// Length 1: One date without spaces
			stringDateTwo = pieces[DATE];
		}

		stringDateOne = processDate(stringDateOne);
		stringDateTwo = processDate(stringDateTwo);

		try {
			dateOne = dateStringMthTime.parse(stringDateOne);
		} catch (ParseException e) {
			try {
				dateOne = dateStringMth.parse(stringDateOne);
			} catch (ParseException f) {
			}
		}
		try {
			dateOne = dateIntMthTime.parse(stringDateOne);
		} catch (ParseException e) {
			try {
				dateOne = dateIntMth.parse(stringDateOne);
			} catch (ParseException f) {
			}
		}

		try {
			dateTwo = dateStringMthTime.parse(stringDateTwo);
		} catch (ParseException e) {
			try {
				dateTwo = dateStringMth.parse(stringDateTwo);
			} catch (ParseException f) {
			}
		}
		try {
			dateTwo = dateIntMthTime.parse(stringDateTwo);
		} catch (ParseException e) {
			try {
				dateTwo = dateIntMth.parse(stringDateTwo);
			} catch (ParseException f) {
			}
		}

		return new DatePair(dateOne, dateTwo);
	}

	private static String processDate(String date) {
		date = date.replaceAll("[:/-]", "");
		date = date.trim();
		return date;
	}

	/*
	 * private static String processMonth(String month) {

		month = month.replaceAll("[^a-zA-Z]", "");
		month = month.trim();
		month = month.toLowerCase();

		if (JAN_STRING.contains(month)) {
			return JAN_INT;
		} else if (FEB_STRING.contains(month)) {
			return FEB_INT;
		} else if (MAR_STRING.contains(month)) {
			return MAR_INT;
		} else if (APR_STRING.contains(month)) {
			return APR_INT;
		} else if (MAY_STRING.contains(month)) {
			return MAY_INT;
		} else if (JUN_STRING.contains(month)) {
			return JUN_INT;
		} else if (JUL_STRING.contains(month)) {
			return JUL_INT;
		} else if (AUG_STRING.contains(month)) {
			return AUG_INT;
		} else if (SEP_STRING.contains(month)) {
			return SEP_INT;
		} else if (OCT_STRING.contains(month)) {
			return OCT_INT;
		} else if (NOV_STRING.contains(month)) {
			return NOV_INT;
		} else if (DEC_STRING.contains(month)) {
			return DEC_INT;
		} else {
			return null;
		}
		
	}
	*/
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\parser\Parser.java
``` java
	/**
	 * Method to check if the delimiters are entered correctly
	 * <p>
	 * This method check that the number of delimiters are correct. There can
	 * only be at most one "<i>-i</i>" and one "<i>-d</i>". This method also
	 * checks that a valid date exists if "<i>-d</i>" is used, and a valid
	 * detail string exists if "<i>-i</i>" is used.
	 * 
	 * @return a string after splitting
	 */
	private Boolean isValidDelim(String input) {
		Boolean valid = true;
		if (input.contains(DATE_DELIMITER)) {
			if (this.getStartDate() == null && this.getEndDate() == null || input.split(DATE_DELIMITER).length > 2) {
				valid = false;
			}
		}
		if (input.contains(DETAIL_DELIMITER)) {
			if (this.getDetails() == null || input.split(DETAIL_DELIMITER).length > 2) {
				valid = false;
			}
		}
		return valid;
	}

	/**
	 * Method to check the format of the string input DATE_DELIMITER=-d
	 * DETAIL_DELIMITER=-i
	 */
	private void checkForDate(String[] input) {
		String[] inputPieces = input[1].split(DATE_DELIMITER, 2);
		if (inputPieces.length == 2) {
			String[] datePieces = inputPieces[1].split(DETAIL_DELIMITER, 2);
			processDate(datePieces[0]);
		} else {
			// Invalid Format
		}
	}

	/**
	 * Method to set correct details from input string
	 * 
	 */
	private void processDetails(String[] input) {
		String[] inputPieces = input[1].split(DETAIL_DELIMITER, 2);
		if (inputPieces.length == 2) {
			String[] detailPieces = inputPieces[1].split(DATE_DELIMITER, 2);
			if (detailPieces[0].trim().length() > 0) {
				details = detailPieces[0];
			} else {
				details = null;
			}
		} else {
			// Invalid Format
			details = null;
		}
	}

	/**
	 * Method to set correct date from input string
	 * 
	 */
	private void processDate(String dateString) {
		DatePair datePair = DateParser.stringToDate(dateString);
		Date firstDate = datePair.getDateOne();
		Date secondDate = datePair.getDateTwo();
		if (firstDate != null && secondDate != null) {
			if (firstDate.after(secondDate)) {
				firstDate = datePair.getDateTwo();
				secondDate = datePair.getDateOne();
			}
		}
		startDate = firstDate;
		endDate = secondDate;
	}

```
###### C:\Users\Barnabas\Documents\GitHub\main\src\parser\Predictive.java
``` java
package parser;

import java.util.Date;

import utilities.COMMANDS;

public class Predictive {

	private static final String ACK_TIP = "Ack/Acknowledge <Item Name> : Marks an item as completed";
	private static final String ADD_TIP = "Add/Insert <Item Name> -d <Starting Date> <Ending Date> -i <Details>";
	private static final String COMPLETED_TIP = "Completed : Displays the list of completed items";
	private static final String DELETE_TIP = "Remove/Delete <Item Index>";
	private static final String EDIT_TIP = "Edit/Change <Item Index> <Task Name> -d <Starting Date> <Ending Date> -i <Details>";
	private static final String FILEPATH_TIP = "Filepath <Directory Path> : Changes file location. Note: Exclude file extension";
	private static final String HOME_TIP = "Home : Displays the original list";
	private static final String SEARCH_TIP = "Find/Search <Keywords> : Displays the list of items containing the keywords";
	private static final String NAME_TIP = "Name <User Name> : Changes the user name";
	private static final String UNDO_TIP = "Undo : Reverts your last changes.";
	private static final String EXIT_TIP = "Exit : Closes the program";
	private static final String EMPTY = "";
	
	private static final String ADD_MSG = "Adding Task...";
	private static final String EDIT_MSG = "Editing Task...";
	private static final String DELETE_MSG = "Delete Task?";
	
	private COMMANDS command;
	private int index;
	private String commandMsg;
	private String taskName;
	private String taskDetails;
	private Date taskStart;
	private Date taskEnd;

	public Predictive() {

	}

	public String processInput(String input) {
		this.resetValues();
		String[] inputPieces = input.split(" ");
		if (inputPieces.length == 1) {
			command = unstrictCommand(inputPieces[0]);
		} else {
			Parser parser = new Parser();
			parser.parse(input);
			this.setCommand(parser.getCommand());
			this.setIndex(parser.getIndex());
			this.setTaskName(parser.getTaskName());
			this.setTaskDetails(parser.getDetails());
			if (parser.getStartDate() != null) {
				this.setTaskStart(parser.getStartDate());
			}
			if (parser.getEndDate() != null) {
				this.setTaskEnd(parser.getEndDate());
			}
		}

		switch (command) {
		case ACK:
			return ACK_TIP;
		case ADD:
			this.setCommandMsg(ADD_MSG);
			return ADD_TIP;
		case COMPLETED:
			return COMPLETED_TIP;
		case DELETE:
			this.setCommandMsg(DELETE_MSG);
			return DELETE_TIP;
		case EDIT:
			this.setCommandMsg(EDIT_MSG);
			return EDIT_TIP;
		case FILEPATH:
			return FILEPATH_TIP;
		case HOME:
			return HOME_TIP;
		case SEARCH:
			return SEARCH_TIP;
		case NAME:
			return NAME_TIP;
		case UNDO:
			return UNDO_TIP;
		case EXIT:
			return EXIT_TIP;
		default:
			return EMPTY;
		}
	}

	private COMMANDS unstrictCommand(String stringCmd) {
		stringCmd = stringCmd.toLowerCase();
		stringCmd = stringCmd.trim();
		if (stringCmd.length() == 0) {
			return COMMANDS.INVALID;
		} else if (Parser.ADD.contains(stringCmd)) {
			return COMMANDS.ADD;
		} else if (Parser.DELETE.contains(stringCmd)) {
			return COMMANDS.DELETE;
		} else if (Parser.EDIT.contains(stringCmd)) {
			return COMMANDS.EDIT;
		} else if (Parser.ACK.contains(stringCmd)) {
			return COMMANDS.ACK;
		} else if (Parser.SEARCH.contains(stringCmd)) {
			return COMMANDS.SEARCH;
		} else if (Parser.HOME.contains(stringCmd)) {
			return COMMANDS.HOME;
		} else if (Parser.UNDO.contains(stringCmd)) {
			return COMMANDS.UNDO;
		} else if (Parser.COMPLETED.contains(stringCmd)) {
			return COMMANDS.COMPLETED;
		} else if (Parser.HELP.contains(stringCmd)) {
			return COMMANDS.HELP;
		} else if (Parser.NAME.contains(stringCmd)) {
			return COMMANDS.NAME;
		} else if (Parser.FILEPATH.contains(stringCmd)) {
			return COMMANDS.FILEPATH;
		} else if (Parser.EXIT.contains(stringCmd)) {
			return COMMANDS.EXIT;
		}else {
			return COMMANDS.INVALID;
		}
	}
	
	public COMMANDS getCommand(){
		return command;
	}
	
	public int getIndex(){
		return index;
	}
	
	public String getCommandMsg(){
		return commandMsg;
	}

	public String getTaskName() {
		return taskName;
	}

	private void setTaskName(String taskName) {
		this.taskName = taskName;
	}

	public String getTaskDetails() {
		return taskDetails;
	}

	private void setTaskDetails(String taskDetails) {
		this.taskDetails = taskDetails;
	}

	public Date getTaskStart() {
		return taskStart;
	}

	private void setTaskStart(Date date) {
		this.taskStart = date;
	}

	public Date getTaskEnd() {
		return taskEnd;
	}

	private void setTaskEnd(Date date) {
		this.taskEnd = date;
	}
	
	private void setCommand(COMMANDS cmd) {
		this.command = cmd;
	}

	private void setCommandMsg(String msg) {
		this.commandMsg = msg;
	}

	private void setIndex(int i) {
		this.index = i;
	}

	private void resetValues() {
		this.setIndex(-1);
		this.setCommand(null);
		this.setCommandMsg(null);
		this.setTaskName(null);
		this.setTaskDetails(null);
		this.setTaskStart(null);
		this.setTaskEnd(null);
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\storage\FileHandler.java
``` java
package storage;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonStreamParser;

import utilities.ErrorProcessor;

/**
 * FileHandler is a class designed to handle all the read/write/save events.
 * <p>
 * The two types of data that are handled here are:
 * <ul>
 * <li>Settings</li>
 * <li>Tasks</li>
 * </ul>
 * 
 * @author Barnabas
 *
 */
public class FileHandler {

	private String fileName;
	private Setting settings;
	private Gson googleJsonBuilder;

	private static final String FILEPATH = "%1$s.json";
	private static final String NULL_ERROR = "Expected non-null Object, Received null Object";
	private static final String SETTINGS_FILE = "settings.json";
	private static final String EMPTY = "";

	/**
	 * Default constructor for a FileHandler Object.
	 * <p>
	 * Here the GoogleJsonBuiler is initialized.
	 */
	public FileHandler() {
		googleJsonBuilder = GoogleJsonBuilder();
	}

	/**
	 * Method to read the list of tasks.
	 * 
	 * @return list of tasks
	 */
	public List<Task> readTasks() {
		List<Task> taskList = readJsonToList();
		return taskList;
	}

	/**
	 * Method to save the list of tasks.
	 * 
	 * @param taskList
	 *            list of tasks
	 * @param completedList
	 *            list of completed tasks
	 * 
	 * @return true if the file is successfully written, false otherwise
	 */
	public boolean saveTasks(List<Task> taskList, List<Task> completedList) {
		assert taskList != null : NULL_ERROR;
		assert completedList != null : NULL_ERROR;
		String jsonTasks = listToJson(taskList);
		jsonTasks += listToJson(completedList);
		return writeToFile(filePath(fileName), jsonTasks);
	}

	/**
	 * Method to read settings.
	 * 
	 * Refer to {@link #getSettings()} for more details.
	 * 
	 * @return true if settings can be read, false otherwise
	 */
	public boolean readSettings() {
		if (this.getSettings() != null) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Method to save settings.
	 * <p>
	 * Refer to {@link #getSettings()} for more details on what is returned.
	 * 
	 * @return returns the settings that have been saved
	 */
	public Setting saveSettings(Setting settings) {
		assert settings != null : NULL_ERROR;
		String jsonTasks = settingsToJson(settings);
		writeToFile(SETTINGS_FILE, jsonTasks);
		return this.getSettings();
	}

	/**
	 * Method to get settings.
	 * <p>
	 * This method get and returns the Settings Object that encapsulates the
	 * settings. At the same time this method records the file name that is
	 * currently being used.
	 * 
	 * @return returns the Settings Object containing the settings
	 */
	public Setting getSettings() {
		settings = readSettingJson();
		if (settings != null) {
			fileName = settings.getFileName();
		} else {
			fileName =Setting.DEFAULT_FILENAME;
		}
		return settings;
	}

	/**
	 * Method to update settings.
	 * <p>
	 * Refer to {@link #saveSettings()} and {@link #getSettings()} for more
	 * details.
	 * 
	 * @param fileName
	 *            name of settings file
	 * @param userName
	 *            the user name of the user in String
	 * @return returns true if the filePath has been changed
	 */
	public boolean isUpdateSettings(String fileName, String userName) {
		boolean isFileUnchanged = false;
		if (settings == null) {
			settings = new Setting();
		}
		if (fileName != null) {
			if(fileName != settings.getFileName()){
				settings.setFileName(fileName);
				isFileUnchanged = true;
			}
		} else {
			settings.setFileName(this.fileName);
		}
		if (userName != null) {
			settings.setUserName(userName);
		}
		this.saveSettings(settings);
		return isFileUnchanged;

	}

	// Writes to file, return true if successfully, false otherwise
	private static boolean writeToFile(String fileName, String content) {
		assert fileName != null : NULL_ERROR;
		assert content != null : NULL_ERROR;
		try {
			FileWriter writer = new FileWriter(fileName);
			writer.write(content);
			writer.close();
			return true;
		} catch (IOException e) {
			ErrorProcessor.alert(FileHandler.class.getName(), e.getMessage());
			return false;
		}
	}

	// Use GSON API to read from settings json file
	private Setting readSettingJson() {
		JsonStreamParser jsonReader = JsonReader(SETTINGS_FILE);
		if (hasNext(jsonReader)) {
			Setting settingEntry = googleJsonBuilder.fromJson(jsonReader.next(), Setting.class);
			return settingEntry;
		}
		return null;
	}

	// Use GSON API to read from tasks json file
	private List<Task> readJsonToList() {
		List<Task> taskList = new ArrayList<Task>();
		JsonStreamParser jsonReader = JsonReader(filePath(fileName));
		if (jsonReader != null) {
			while (hasNext(jsonReader)) {
				Task taskEntry = googleJsonBuilder.fromJson(jsonReader.next(), Task.class);
				taskList.add(taskEntry);
			}
		}
		return taskList;
	}

	// Attempt to create a new file and returns JsonStreamParser
	private JsonStreamParser JsonReader(String fileName) {
		assert fileName != null : NULL_ERROR;
		File fileToRead = new File(fileName);
		try {
			fileToRead.createNewFile();
			return new JsonStreamParser(new FileReader(fileToRead));
		} catch (FileNotFoundException e) {
			ErrorProcessor.alert(FileHandler.class.getName(), e.getMessage());
			return null;
		} catch (IOException e) {
			ErrorProcessor.alert(FileHandler.class.getName(), e.getMessage());
			return null;
		}
	}

	private boolean hasNext(JsonStreamParser jsonReader) {
		assert jsonReader != null : NULL_ERROR;
		try {
			return jsonReader.hasNext();
		} catch (com.google.gson.JsonIOException e) {
			// Thrown when json file empty
			return false;
		}
	}

	private String listToJson(List<Task> taskList) {
		assert taskList != null : NULL_ERROR;
		String jsonString = EMPTY;
		for (int i = 0; i < taskList.size(); i++) {
			Task task = taskList.get(i);
			jsonString += googleJsonBuilder.toJson(task);
		}
		return jsonString;
	}

	private String settingsToJson(Setting settings) {
		assert settings != null : NULL_ERROR;
		String jsonString = googleJsonBuilder.toJson(settings);
		return jsonString;
	}

	private String filePath(String fileName){
		return String.format(FILEPATH, fileName);
	}
	private static Gson GoogleJsonBuilder() {
		return new GsonBuilder().setPrettyPrinting().create();
	}

}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\storage\Setting.java
``` java
package storage;


/**
 * Settings is a class representation of settings. It contains the following
 * information:
 * <ul>
 * <li>Task Filepath: Indicates where the list of tasks are stored.</li>
 * <li>User Name</li>
 * </ul>
 * 
 * @author Barnabas
 *
 */

public class Setting {
	private String fileName;
	private String userName;

	public static final String DEFAULT_FILENAME = "task";

	/**
	 * Default constructor for a Task Object.
	 * <p>
	 * The default file name is set to <i>"task"</i> and the default user
	 * name is set to <i>null</i>.
	 * <p>
	 * Refer to {@link #Settings(String, String)}.
	 */
	public Setting() {
		this(DEFAULT_FILENAME, null);
	}

	/**
	 * Constructor to create a Task Object.
	 * <p>
	 * Takes in the parameters for the file name and user name and sets the file
	 * path and user names accordingly.
	 * <p>
	 * Refer to {@link #setFileName(String)}, {@link #setUserName(String)}.
	 * 
	 * @param taskFileName
	 *            the file name as a String
	 * @param userName
	 *            the name of the user as a String
	 */
	public Setting(String taskFileName, String userName) {
		this.setFileName(taskFileName);
		this.setUserName(userName);
	}

	/**
	 * Method to get the file name
	 * 
	 * @return the file path as a String
	 */
	public String getFileName() {
		return fileName;
	}

	/**
	 * Method to set the file name
	 * 
	 * @param taskFileName
	 *            the file name as a String
	 */
	public void setFileName(String taskFileName) {
		if (taskFileName == null) {
			taskFileName = DEFAULT_FILENAME;
		}
		fileName = taskFileName;
	}

	/**
	 * Method to get the user name
	 * 
	 * @return the user name as a String
	 */
	public String getUserName() {
		return userName;
	}

	/**
	 * Method to set the user name
	 * 
	 * @param userName
	 *            the user name as a String
	 */
	public void setUserName(String userName) {
		this.userName = userName;
	}

}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\storage\Storage.java
``` java
package storage;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Stack;
import java.util.logging.Logger;

import utilities.DatePair;
import utilities.DayProcessor;

/**
 * Storage is a class that provides the basic add/remove/delete/edit functions.
 * <p>
 * It depends on the FileHandler class for retrieving and storing the data to a
 * file.
 * 
 * @author Barnabas
 *
 */

public class Storage {
	private static List<Task> taskList;
	private static List<Task> completedList;
	private static Stack<Task> recentChanges;
	private static TaskComparator taskComparator;
	private static FileHandler fileHandler;

	private boolean isTestMode;

	// Assert message
	private static final String NULL_ERROR = "Expected non-null Object, Received null Object";

	// Logging, and Log messages
	private static final Logger logger = Logger.getLogger(Storage.class.getName());
	private static final String TASK_ADDED = "Task added: \"%1$s\"";
	private static final String TASK_BACKUP = "Backup mode: \"%1$s\"";
	private static final String TASK_DUPLICATE = "Duplicate task, not added: \"%1$s\"";
	private static final String TASK_DELETED = "Task deleted: \"%1$s\"";
	private static final String TASK_UNDO = "Task has been undone ";
	private static final String TASK_NO_UNDO = "Nothing to undo";
	private static final String TASK_SEARCH = "Searching: \"%1$s\"";
	private static final String TASK_EDITED = "Edited: \"%1$s\"";
	private static final String TASK_ACK = "Acked: \"%1$s\"";
	private static final String NAME_SET = "Name Changed: \"%1$s\"";

	/**
	 * Default constructor for a Storage Object.
	 * <p>
	 * The testing parameter is set to false by default.
	 */
	public Storage() {
		this(false);
	}

	/**
	 * Constructor for a Storage Object.
	 * <p>
	 * If the test mode is true, there is testing in progress. The data
	 * processed will not be read from or saved to a file.
	 * 
	 * @param isTestMode
	 *            enter true if testing, false otherwise
	 */
	public Storage(boolean isTestMode) {
		this.isTestMode = isTestMode;
		taskList = new ArrayList<Task>();
		completedList = new ArrayList<Task>();
		taskComparator = new TaskComparator();
		recentChanges = new Stack<Task>();
		if (!isTestMode) {
			this.init();
		}
	}

	/**
	 * Method to get the list of tasks
	 * 
	 * @return the list of tasks
	 */
	public List<Task> getTaskList() {
		this.shiftCompleted();
		taskList.sort(taskComparator);
		return taskList;
	}

	/**
	 * Method to get the list of completed tasks
	 * 
	 * @return the list of completed tasks
	 */
	public List<Task> getCompletedList() {
		completedList.sort(taskComparator);
		return completedList;
	}

	/**
	 * Method to read the taskList from a json file
	 * 
	 * @return returns the user name, returns null if in test mode
	 */
	public String readFile() {
		if (!isTestMode) {
			taskList = fileHandler.readTasks();
			completedList.clear();
			this.shiftCompleted();
		}
		return null;
	}

	/**
	 * Method to read the settings from a json file
	 * 
	 * @return returns the user name, returns null if no settings found
	 */
	public String readSettings() {
		if (fileHandler.getSettings() != null) {
			return fileHandler.getSettings().getUserName();
		} else {
			return null;
		}
	}

	/**
	 * Method to set the settings
	 * 
	 * @param userName
	 *            the user name in String
	 * @param filePath
	 *            the file location in string
	 * 
	 * @return the current user name
	 */
	public void setSettings(String userName, String filePath) {
		if(fileHandler.isUpdateSettings(filePath, userName)){
			recentChanges.clear();
		}
		this.readFile();
	}

	/**
	 * Method to set the user name
	 * 
	 * @param userName
	 *            the user name in String
	 * 
	 * @return the current user name
	 */
	public String setUser(String userName) {
		fileHandler.isUpdateSettings(null, userName);
		logger.info(String.format(NAME_SET, userName));
		return fileHandler.getSettings().getUserName();
	}

	/**
	 * Method to search for tasks
	 * 
	 * @param searchTerm
	 *            the string to find
	 * @return searchList containing the tasks that has the string
	 */
	public List<Task> search(String searchTerm) {
		List<Task> searchList = new ArrayList<Task>();
		for (Task task : taskList) {
			if (task.contains(searchTerm)) {
				searchList.add(task);
			}
		}
		logger.info(String.format(TASK_SEARCH, searchTerm));
		return searchList;
	}

	/**
	 * Method to add a task
	 * 
	 * @param name
	 *            name of the task to add
	 * @param details
	 *            details of the task to add
	 * @param startDate
	 *            starting date of the task to add
	 * @param endDate
	 *            ending date of the task to add
	 * @return Task that was added, if not added, return null
	 */
	public String add(String name, String details, Date startDate, Date endDate) {
		Task newTask = new Task(name, details, startDate, endDate);
		if (isNotDuplicate(newTask)) {
			taskList.add(newTask);
			recentChanges.push(newTask);
			taskList.sort(taskComparator);
			this.saveFile();
			logger.info(String.format(TASK_ADDED, name));
			return newTask.getName();
		} else {
			logger.info(String.format(TASK_DUPLICATE, name));
			return null;
		}
	}

	/**
	 * Method to delete a task
	 * 
	 * @param index
	 *            index of the task to delete
	 * @return Task that was deleted, if not deleted, return null
	 */
	public String delete(int index) {
		String name = null;
		if (isValidIndex(index)) {
			recentChanges.push(taskList.get(index));
			 name = taskList.remove(index).getName();
			this.saveFile();
			logger.info(String.format(TASK_DELETED, taskList.get(index).getName()));
			return name;
		} else {
			return name;
		}
	}

	/**
	 * Method to edit a task
	 * 
	 * @param index
	 *            index of the task to edit
	 * @param taskName
	 *            the new string to replace the previous name
	 * @param details
	 *            the new string to replace the previous details
	 * @param startDate
	 *            the new starting date to replace the previous starting date
	 * @param endDate
	 *            the new ending date to replace the previous ending date
	 * @return the old name of the edited task, if index is not valid, return null
	 */
	public String edit(int index, String taskName, String details, Date startDate, Date endDate) {
		if (isValidIndex(index)) {
			Task currTask = backup(index);
			String name = taskList.get(index).getName();
			if (taskName != null) {
				currTask.setName(taskName);
			}
			if (details != null) {
				currTask.setDetails(details);
			}
			if (startDate != null) {
				currTask.setStartDate(startDate);
			}
			if (endDate != null) {
				startDate = currTask.getStartDate();
				if(startDate != null){
					DatePair orderedDate = DayProcessor.orderDate(startDate, endDate);
					startDate = orderedDate.getDateOne();
					endDate = orderedDate.getDateTwo();
					currTask.setStartDate(startDate);
				}
				currTask.setEndDate(endDate);
			}
			logger.info(String.format(TASK_EDITED, name));
			this.saveFile();
			return name;
		} else {
			return null;
		}
	}

	/**
	 * Method to flag a task as complete
	 * 
	 * @param index
	 *            index of the task to flag as completed
	 * @return nams of task that was flagged as complete, if index is not valid, return
	 *         null
	 */
	public String complete(int index) {
		if (isValidIndex(index)) {
			Task currTask = backup(index);
			completedList.add(currTask);
			currTask.setCompleted(true);
			taskList.remove(index);
			logger.info(String.format(TASK_ACK, currTask.getName()));
			this.saveFile();
			return currTask.getName();
		} else {
			return null;
		}
	}

	/**
	 * Method to Undo the last change made
	 * <p>
	 * This method checks if the recent task in recentChanges exists in taskList
	 * and remove it from taskList (Undo Add). Else checks if task id a task in
	 * taskList and reverts changes(Undo Edit). Else add it to taskList (Undo
	 * DELETE).
	 * 
	 * @return true if there are changes to undo, false otherwise
	 */
	public String undo() {
		if (!recentChanges.isEmpty()) {
			Task oldTask = recentChanges.pop();
			if (!this.isUndoAdd(oldTask)) {
				if (!this.isUndoEdit(oldTask)) {
					if (!this.isUndoAck(oldTask)) {
						this.undoDelete(oldTask);
					}
				}
			}
			this.saveFile();
			logger.info(TASK_UNDO);
			return oldTask.getName();
		}
		logger.info(TASK_NO_UNDO);
		return null;
	}

	// **SUPPORTING FUNCTIONS FOR UNDO**

	private boolean isUndoAdd(Task oldTask) {
		assert oldTask != null : NULL_ERROR;
		if (taskList.contains(oldTask)) {
			taskList.remove(oldTask);
			return true;
		}
		return false;
	}

	private boolean isUndoEdit(Task oldTask) {
		assert oldTask != null : NULL_ERROR;
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getTaskId() == oldTask.getTaskId()) {
				this.clone(taskList.get(i), oldTask);
				return true;
			}
		}
		return false;
	}

	private boolean isUndoAck(Task oldTask) {
		assert oldTask != null : NULL_ERROR;
		for (int i = 0; i < completedList.size(); i++) {
			if (completedList.get(i).getTaskId() == oldTask.getTaskId()) {
				completedList.remove(completedList.get(i));
				taskList.add(oldTask);
				return true;
			}
		}
		return false;
	}

	private void undoDelete(Task oldTask) {
		taskList.add(oldTask);
	}

	private void clone(Task currTask, Task oldTask) {
		assert currTask != null : NULL_ERROR;
		assert oldTask != null : NULL_ERROR;
		currTask.setName(oldTask.getName());
		currTask.setDetails(oldTask.getDetails());
		currTask.setStartDate(oldTask.getStartDate());
		currTask.setEndDate(oldTask.getEndDate());
		currTask.setCompleted(oldTask.isCompleted());
	}

	// **SUPPORTING FUNCTIONS FOR COMPLETE**

	// Backs up a task to recentChanges, returns a new instance of the old task
	// for editing
	private Task backup(int index) {
		Task currTask = taskList.get(index);
		Task oldTask = this.backupTask(currTask);
		recentChanges.push(oldTask);
		assert currTask.getTaskId() == oldTask.getTaskId();
		logger.info(String.format(TASK_BACKUP, oldTask));
		return currTask;
	}

	private Task backupTask(Task currTask) {
		Task oldTask = new Task(currTask.getName(), currTask.getDetails(), currTask.getStartDate(),
				currTask.getEndDate());
		oldTask.setCompleted(currTask.isCompleted());
		oldTask.setTaskId(currTask.getTaskId());
		return oldTask;
	}

	// **SUPPORTING FUNCTION FOR ADD**

	// Compare hash code, then taskId to determine if task is a duplicate
	private boolean isNotDuplicate(Task newTask) {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).getHashCode() == newTask.getHashCode()) {
				return false;
			} else if (taskList.get(i).getTaskId() == newTask.getTaskId()) {
				newTask.resetTaskId();
				return true;
			}
		}
		return true;
	}

	// **SUPPORTING FUNCTION FOR READFILE**

	private void shiftCompleted() {
		for (int i = 0; i < taskList.size(); i++) {
			if (taskList.get(i).isCompleted()) {
				completedList.add(taskList.get(i));
				taskList.remove(i);
			}
		}
	}

	// **SUPPORTING FUNCTIONS FOR CONSTRUCTOR**

	private void init() {
		fileHandler = new FileHandler();
		this.readSettings();
		this.readFile();
	}

	// **SUPPORTING FUNCTIONS FOR ALL**

	private boolean saveFile() {
		if (!isTestMode) {
			return fileHandler.saveTasks(taskList, completedList);
		}
		return false;
	}

	private boolean isValidIndex(int index) {
		if (index < taskList.size() && index >= 0) {
			return true;
		} else {
			return false;
		}
	}

	// The following code have been removed due to changes in the way the dates
	// are handled. They are left here in case there is a need to refer to them.
	// /**
	// * Method to edit a task
	// *
	// * @param index
	// * index of the task to flag as completed
	// * @param newName
	// * the new string to replace the previous name
	// * @return Task that was edited, if index is not valid, return null
	// */
	// public Task edit(int index, String newName) {
	// if (isValidIndex(index)) {
	// Task currTask = taskList.get(index);
	// Task oldTask = new Task(currTask.getName(), currTask.getDetails(),
	// currTask.getStartDate(),
	// currTask.getEndDate());
	// oldTask.setCompleted(currTask.isCompleted());
	// recentChanges.push(oldTask); // Backup old task
	// taskList.get(index).setName(newName); // Edit name
	// assert taskList.get(index).getTaskId() == oldTask.getTaskId();
	// return taskList.get(index);
	// } else {
	// return null;
	// }
	// }
	//
	// /**
	// * Method to edit a task
	// *
	// * @param index
	// * index of the task to flag as completed
	// * @param newName
	// * the new string to replace the previous name
	// * @param name
	// * true if editing name, false if editing details
	// * @return Task that was edited, if index is not valid, return null
	// */
	// public Task edit(int index, String newName, boolean name) {
	// if (isValidIndex(index)) {
	// Task currTask = taskList.get(index);
	// Task oldTask = new Task(currTask.getName(), currTask.getDetails(),
	// currTask.getStartDate(),
	// currTask.getEndDate());
	// oldTask.setCompleted(currTask.isCompleted());
	// recentChanges.push(oldTask); // Backup old task
	// if (name) {
	// taskList.get(index).setName(newName); // Edit name
	// } else {
	// taskList.get(index).setDetails(newName); // Edit details
	// }
	// assert taskList.get(index).getTaskId() == oldTask.getTaskId();
	// return taskList.get(index);
	// } else {
	// return null;
	// }
	// }
	//
	// /**
	// * Method to edit a task
	// *
	// * @param index
	// * index of the task to flag as completed
	// * @param newDate
	// * the new date to replace the previous date
	// * @param startDate
	// * true if replacing the starting date, false otherwise
	// * @return Task that was edited, if index is not valid, return null
	// */
	// public Task edit(int index, Date newDate, boolean startDate) {
	// if (isValidIndex(index)) {
	// Task currTask = taskList.get(index);
	// Task oldTask = new Task(currTask.getName(), currTask.getDetails(),
	// currTask.getStartDate(),
	// currTask.getEndDate());
	// oldTask.setCompleted(currTask.isCompleted());
	// recentChanges.push(oldTask); // Backup old task
	// if (startDate) {
	// taskList.get(index).setStartDate(newDate); // Edit starting date
	// } else {
	// taskList.get(index).setEndDate(newDate); // Edit ending date
	// }
	// assert taskList.get(index).getTaskId() == oldTask.getTaskId();
	// return taskList.get(index);
	// } else {
	// return null;
	// }
	// }

}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\storage\Task.java
``` java
package storage;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

/**
 * Task is a class representation of a task. It contains the following
 * information:
 * <ul>
 * <li>Task Id</li>
 * <li>Task Name</li>
 * <li>Task Details</li>
 * <li>Starting Date</li>
 * <li>Ending Date</li>
 * <li>Is Completed</li>
 * </ul>
 * 
 * @author Barnabas
 *
 */

public class Task {

	private int taskId;
	private String name;
	private String details;
	private Date startDate;
	private Date endDate;
	private boolean isCompleted;

	// Strings
	private static final String EMPTY = null;
	private static final String SPACE = "%1$s ";
	private static final String DATE_FORMAT = "dd MMMM yyyy hh:mm a";
	private static final String TASK_STRING = "Task [name= %1$s, details= %2$s, startDate= %3$s, endDate= %4$s, completed= %5$s]";

	// Due tags
	public static final int NODATE = 0;
	public static final int OVERDUE = 1;
	public static final int TODAY = 2;
	public static final int TOMORROW = 3;
	public static final int UPCOMING = 4;

	private static final int DAYS_IN_YEAR = 365;
	private static final int ZERO_DAYS = 0;
	private static final int ONE_DAY = 1;

	// *************************************** CONSTRUCTOR
	/**
	 * Default constructor for a Task Object.
	 * <p>
	 * All parameters are set to null, refer to
	 * {@link #Task(String, String, Date, Date)}
	 */
	public Task() {
		this(null, null, null, null);
	}

	/**
	 * Constructor to create a Task Object without details and an ending date.
	 * <p>
	 * The starting date and details are set to null, other than that refer to
	 * {@link #Task(String, String, Date, Date)}.
	 * 
	 * @param name
	 *            the name of the task in String
	 * @param date
	 *            the due date of the task as a Date Object
	 */
	public Task(String name, Date date) {
		this(name, null, null, date);
	}

	/**
	 * Constructor to create a Task Object without any dates.
	 * <p>
	 * The dates is set to null, other than that refer to
	 * {@link #Task(String, String, Date, Date)}.
	 * 
	 * @param name
	 *            the name of the task in String
	 * @param details
	 *            the details of the task in String
	 */
	public Task(String name, String details) {
		this(name, details, null, null);
	}

	/**
	 * Constructor to create a Task Object without an ending date.
	 * <p>
	 * The starting date is set to null, other than that refer to
	 * {@link #Task(String, String, Date, Date)}.
	 * 
	 * @param name
	 *            the name of the task in String
	 * @param details
	 *            the details of the task in String
	 * @param date
	 *            the due date of the task as a Date Object
	 */
	public Task(String name, String details, Date date) {
		this(name, details, null, date);
	}

	/**
	 * Constructor to create a Task Object.
	 * <p>
	 * Default behavior of a Task Object:
	 * <ul>
	 * <li>completed flag set to false</li>
	 * <li>task id calculated by hashCode</li>
	 * </ul>
	 * 
	 * @param name
	 *            the name of the task in String
	 * @param details
	 *            the details of the task in String
	 * @param startDate
	 *            the starting date of the task as a Date Object
	 * @param endDate
	 *            the ending date of the task as a Date Object
	 */
	public Task(String name, String details, Date startDate, Date endDate) {
		this.setName(name);
		this.setStartDate(startDate);
		this.setEndDate(endDate);
		this.setDetails(details);
		this.setCompleted(false);
		this.setTaskId();
	}

	// *************************************** TASK ID
	/**
	 * Method to get the Id of a Task Object.
	 * <p>
	 * The task id is created based on the initial hash code of the Task Object.
	 * Refer to {@link #getHashCode()} for how the hash code is calculated.
	 * 
	 * @return the Id as a int
	 */
	public int getTaskId() {
		return taskId;
	}

	// Set the task id to the initial hash code
	private void setTaskId() {
		taskId = getHashCode();
	}

	/**
	 * Method to set the Task Id.
	 * 
	 * @param taskId
	 *            the int representation of the Task Id
	 */
	public void setTaskId(int taskId) {
		this.taskId = taskId;
	}

	/**
	 * Method to reset the Task Id.
	 * <p>
	 * This method should only be called if the task id collides. This method
	 * simply increments the original task id by 1 to prevent collision.
	 */
	public void resetTaskId() {
		taskId += 1;
	}

	/**
	 * Method to get the hash code of a Task Object.
	 * <p>
	 * This method calculates the hash code using the String.hashCode()
	 * function. The hash code is calculate based on the strings of the
	 * following unique elements:
	 * <ul>
	 * <li>Name</li>
	 * <li>Details</li>
	 * <li>Full Staring Date</li>
	 * <li>Full Ending Date</li>
	 * </ul>
	 * 
	 * @return the hash code as a String
	 */
	public int getHashCode() {
		String uniqueElements = this.getName() + this.getDetails() + this.getStartDateString()
				+ this.getEndDateString();
		return uniqueElements.hashCode();
	}

	// *************************************** NAME
	/**
	 * Method to get the name of a Task Object.
	 * 
	 * @return the name as a String
	 */
	public String getName() {
		return name;
	}

	/**
	 * Method to set the name of a Task Object.
	 * 
	 * @param name
	 *            the String representation of the name
	 */
	public void setName(String name) {
		this.name = name;
	}

	// *************************************** DETAILS
	/**
	 * Method to get the details of a Task Object.
	 * 
	 * @return the details as a String
	 */
	public String getDetails() {
		return details;
	}

	/**
	 * Method to set the details of a Task Object.
	 * 
	 * @param details
	 *            the String representation of the details
	 */
	public void setDetails(String details) {
		this.details = details;
	}

	// *************************************** START DATE
	/**
	 * Method to get the starting date of a Task Object.
	 * 
	 * @return the starting date as a Date Object
	 */
	public Date getStartDate() {
		return startDate;
	}

	/**
	 * Method to retrieve a the starting date in string form.
	 * <p>
	 * This method returns the starting date in the format <i>
	 * "dd MMMM yyyy hh:mm a"</i> . Where <i>dd</i> denotes day of the month,
	 * <i>MMMM</i> denotes month of the year, <i>yyyy</i> denotes year,
	 * <i>hh</i> denotes hour, <i>mm</i> denotes minutes & <i>a</i> denotes
	 * am/pm.
	 * 
	 * @return The string value of the starting date. If no starting date
	 *         exists, returns "Empty"
	 */
	public String getStartDateString() {
		Date startDate = this.getStartDate();
		if (startDate != null) {
			return this.getDateString(startDate);
		} else {
			return EMPTY;
		}
	}

	/**
	 * Method to set the starting date of a Task Object.
	 * 
	 * @param startDate
	 *            Date object as the starting date of a Task
	 */
	public void setStartDate(Date startDate) {
		this.startDate = startDate;
	}

	// *************************************** END DATE

	/**
	 * Method to get the ending date of a Task Object.
	 * 
	 * @return the ending date as a Date Object
	 */
	public Date getEndDate() {
		return endDate;
	}

	/**
	 * Method to retrieve a the ending date in string form.
	 * <p>
	 * This method returns the ending date in the format <i>
	 * "dd MMMM yyyy hh:mm a"</i> . Where <i>dd</i> denotes day of the month,
	 * <i>MMMM</i> denotes month of the year, <i>yyyy</i> denotes year,
	 * <i>hh</i> denotes hour, <i>mm</i> denotes minutes & <i>a</i> denotes
	 * am/pm.
	 * 
	 * @return the string value of the full ending date, "Empty" if no ending
	 *         date exists
	 */
	public String getEndDateString() {
		Date endDate = this.getEndDate();
		if (endDate != null) {
			return this.getDateString(endDate);
		} else {
			return EMPTY;
		}
	}

	/**
	 * Method to set the ending date of a Task Object.
	 * 
	 * @param endDate
	 *            Date object as the ending date of a Task
	 */
	public void setEndDate(Date endDate) {
		this.endDate = endDate;
	}

	// *************************************** IS COMPLETED

	/**
	 * Method to check the isCompleted flag of a Task Object.
	 * 
	 * @return truth value of the isCompleted flag
	 */
	public boolean isCompleted() {
		return isCompleted;
	}

	/**
	 * Method to set the completed flag of a Task Object.
	 * 
	 * @param isCompleted
	 *            true to indicate completed, false to indicate not completed.
	 */
	public void setCompleted(boolean isCompleted) {
		this.isCompleted = isCompleted;
	}

	// *************************************** CONTAINS, SEARCHING

	/**
	 * Method to check if the Task Object contains a search term.
	 * 
	 * @return true if the search term exists
	 * @param searchTerm
	 *            the string to search for
	 */
	public boolean contains(String searchTerm) {
		searchTerm = searchTerm.toLowerCase();
		String searchString = this.toStringNoNull();
		if (searchString.contains(searchTerm)) {
			return true;
		}
		return false;
	}

	// *************************************** DUE

	/**
	 * Method to check when the task Object is due relative to today
	 * 
	 * @return -1 if the task is overdue, 0 if the task is due today, 1 if the
	 *         task is due tomorrow, 2 any other task is due within a week, 3
	 *         remaining tasks
	 */
	public int due() {
		if (this.getEndDate() != null) {
			Calendar endDate = Calendar.getInstance();
			endDate.setTime(this.getEndDate());
			int endDayInt = endDate.get(Calendar.DAY_OF_YEAR);
			endDayInt += endDate.get(Calendar.YEAR) * DAYS_IN_YEAR;

			// current date
			Calendar toDay = Calendar.getInstance();
			int toDayInt = toDay.get(Calendar.DAY_OF_YEAR);
			toDayInt += toDay.get(Calendar.YEAR) * DAYS_IN_YEAR;

			int diff = endDayInt - toDayInt;

			if (diff < ZERO_DAYS) {
				return OVERDUE;
			} else if (diff == ZERO_DAYS) {
				return TODAY;
			} else if (diff == ONE_DAY) {
				return TOMORROW;
			} else {
				return UPCOMING;
			}
		} else {
			return NODATE;
		}
	}

	// *************************************** LOW LEVEL FUNCTIONS

	private String toStringNoNull() {

		String fullString = "";

		if (this.getName() != null) {
			fullString += String.format(SPACE, this.getName().toLowerCase());
		}
		if (this.getDetails() != null) {
			fullString += String.format(SPACE, this.getDetails().toLowerCase());
		}
		if (this.getStartDateString() != null) {
			fullString += String.format(SPACE, this.getStartDateString().toLowerCase());
		}
		if (this.getEndDateString() != null) {
			fullString += String.format(SPACE, this.getEndDateString().toLowerCase());
		}
		return fullString;
	}

	private String getDateString(Date date) {
		assert date != null;
		SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
		return dateFormat.format(date);
	}

	@Override
	public String toString() {
		return String.format(TASK_STRING, name, details, startDate, endDate, isCompleted);
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\storage\TaskComparator.java
``` java
package storage;

import java.util.Comparator;

/**
 * TaskComparator handles how Tasks are sorted
 * <p>
 * Currently tasks are sorted in the following order; Tasks without dates are at
 * the top (Sorted by task name, then details), followed by tasks with dates
 * (Sorted by starting dates, then ending dates).
 * 
 * @author Barnabas
 *
 */
public class TaskComparator implements Comparator<Task> {

	public static final int SAME = 0;
	private static final int GREATER_THAN = 1;
	private static final int LESSER_THAN = -1;

	@Override
	public int compare(Task first, Task second) {
		int result = SAME;

		if (first.getEndDate() != null && second.getEndDate() != null) {
			result = first.getEndDate().compareTo(second.getEndDate());

			// If End Dates are the same, compare Start Dates
			if (result == SAME && first.getStartDate() != null && second.getStartDate() != null) {
				result = first.getStartDate().compareTo(second.getStartDate());
				// TODO check if storing start dates in correct order
			} else if (result == SAME && first.getStartDate() == null && second.getStartDate() != null) {
				result = GREATER_THAN;
			} else if (result == SAME && first.getStartDate() != null && second.getStartDate() == null) {
				result = LESSER_THAN;
			} 

		} else if (first.getEndDate() == null && second.getEndDate() != null) {
			result = LESSER_THAN;
		} else if (first.getEndDate() != null && second.getEndDate() == null) {
			result = GREATER_THAN;
		} else {

		}

		// Either no dates, or start/end dates are the same
		if (result == SAME) {

			result = first.getName().compareTo(second.getName());

			// Both Task names are same, attempt to sort by details
			if (result == SAME && first.getDetails() != null && second.getDetails() != null) {
				result = first.getDetails().compareTo(second.getDetails());
			}
		}
		return result;
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\utilities\COMMANDS.java
``` java
package utilities;

/**
 * COMMANDS is a class file that contain the command types.
 * <p>
 * This class is to ensure that all components standardize to the same set of
 * commands.
 *
 */
public enum COMMANDS {
	ADD, DELETE, EDIT, ACK, SEARCH, INVALID, EXIT, HOME, UNDO, COMPLETED, HELP, NAME, FILEPATH
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\utilities\DatePair.java
``` java
package utilities;

import java.util.Date;

/**
 * DatePair is a class representation of a pair of dates.
 * 
 * @author Barnabas
 *
 */

public class DatePair {
	private Date dateOne;
	private Date dateTwo;

	public DatePair(Date dateOne, Date dateTwo) {
		this.setDateOne(dateOne);
		this.setDateTwo(dateTwo);
	}

	public Date getDateOne() {
		return dateOne;
	}

	public void setDateOne(Date dateOne) {
		this.dateOne = dateOne;
	}

	public Date getDateTwo() {
		return dateTwo;
	}

	public void setDateTwo(Date dateTwo) {
		this.dateTwo = dateTwo;
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\utilities\DayProcessor.java
``` java
package utilities;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import utilities.DatePair;

public class DayProcessor {

	private final static String DAY_OF_THE_WEEK = "EEEE";
	private final static String TODAYS_DATE = "dd MMMM";
	private static final String DATE_FORMAT = "dd MMMM yyyy hh:mm a";

	public static String todayDay() {
		DateFormat dateFormat = new SimpleDateFormat(DAY_OF_THE_WEEK);
		Date date = new Date();
		return dateFormat.format(date);
	}

	public static String todayDate() {
		DateFormat dateFormat = new SimpleDateFormat(TODAYS_DATE);
		Date date = new Date();
		return dateFormat.format(date);
	}
	
	public static String formatDate(Date date){
		if(date != null){
		SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
		return dateFormat.format(date);
		} else {
			return null;
		}
	}
	
	public static DatePair orderDate(Date date1, Date date2){
		Date firstDate = date1;
		Date secondDate = date2;
		if (firstDate != null && secondDate != null) {
			if (firstDate.after(secondDate)) {
				firstDate = date2;
				secondDate = date1;
			}
		}
		return new DatePair(firstDate, secondDate);
	}
}
```
###### C:\Users\Barnabas\Documents\GitHub\main\src\utilities\ErrorProcessor.java
``` java
package utilities;

import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;

/**
 * ErrorProcessor is a class to generate error messages in GUI to alert the
 * user.
 * 
 * @author Barnabas
 *
 */
public class ErrorProcessor {

	private static final String ERROR_TITLE = "Error";
	private static final String ERROR_TRIGGERED = "Error Triggered";
	private static final String ERROR_TRIGGERED_AT = "Error Triggered at ";

	/**
	 * Method to display an error message.
	 * 
	 * @param error
	 *            the error message in String
	 */
	public static void alert(String error) {
		try {
			Alert alert = new Alert(AlertType.ERROR);
			alert.setTitle(ERROR_TITLE);
			alert.setHeaderText(ERROR_TRIGGERED);
			alert.setContentText(error);
			alert.showAndWait();
		} catch (java.lang.ExceptionInInitializerError e) {
			// Exception only thrown when javaFx 8 not properly initialised
			System.out.println(error);
		}
	}

	/**
	 * Method to display an error message.
	 * 
	 * @param errorLocation
	 *            the location of the error in String
	 * @param error
	 *            the error message in String
	 */
	public static void alert(String errorLocation, String error) {
		try {
			Alert alert = new Alert(AlertType.ERROR);
			alert.setTitle(ERROR_TITLE);
			alert.setHeaderText(ERROR_TRIGGERED_AT + errorLocation);
			alert.setContentText(error);
			alert.showAndWait();
		} catch (java.lang.ExceptionInInitializerError e) {
			System.out.println(ERROR_TRIGGERED_AT + errorLocation);
			System.out.println(error);
		}
	}
}
```
